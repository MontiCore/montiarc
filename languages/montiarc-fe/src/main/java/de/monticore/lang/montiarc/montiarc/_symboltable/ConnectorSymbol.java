package de.monticore.lang.montiarc.montiarc._symboltable;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Optional;

import de.monticore.lang.montiarc.helper.SymbolPrinter;
import de.monticore.lang.montiarc.tagging._symboltable.TaggingSymbol;
import de.se_rwth.commons.Joiners;
import de.se_rwth.commons.Splitters;
import de.se_rwth.commons.logging.Log;

/**
 * Symboltable entry for connectors.
 *
 * @author Arne Haber, Michael von Wenckstern
 */
public class ConnectorSymbol extends TaggingSymbol {

  /* generated by template symboltable.symbols.KindConstantDeclaration*/

  public static final ConnectorKind KIND = ConnectorKind.INSTANCE;

  private final Map<String, Optional<String>> stereotype = new HashMap<>();

  /**
   * Source of this connector.
   */
  protected String source;

  /**
   * Target of this connector.
   */
  protected String target;

  /**
   * use {@link #builder()}
   */
  protected ConnectorSymbol(String name) {
    super(name, KIND);
  }

  public static ConnectorBuilder builder() {
    return new ConnectorBuilder();
  }

  /**
   * @return the source
   */
  public String getSource() {
    return source;
  }

  /**
   * @param source the source to set
   */
  public void setSource(String source) {
    this.source = source;
  }

  protected PortSymbol getPort(String name) {
    if (this.getEnclosingScope() == null) {
      Log.warn("Connector does not belong to a component, cannot resolve port");
      return null;
    }
    if (!this.getEnclosingScope().getSpanningSymbol().isPresent()) {
      Log.warn("Connector is not embedded in component symbol or expanded component instance symbol, cannot resolve port");
      return null;
    }

    // (1) try to load Component.Port or ExpandedComponentInstance.Port
    String fullSource = Joiners.DOT.join(this.getPackageName(),
        this.getEnclosingScope().getSpanningSymbol().get().getName(), name);
    Optional<PortSymbol> port = this.getEnclosingScope().<PortSymbol>resolve(fullSource, PortSymbol.KIND);
    if (port.isPresent()) {
      return port.get();
    }

    if (!(this.getEnclosingScope().getSpanningSymbol().get() instanceof ComponentSymbol)) {
      Log.warn("Connector is not embedded in component symbol, cannot resolve port");
      return null;
    }
    ComponentSymbol cmp = (ComponentSymbol) this.getEnclosingScope().getSpanningSymbol().get();

    // (2) try to load Component.instance.Port
    Iterator<String> parts = Splitters.DOT.split(name).iterator();
    if (!parts.hasNext()) {
      Log.warn("name of connector's source/target is empty, cannot resolve port");
      return null;
    }
    String instance = parts.next();
    if (!parts.hasNext()) {
      Log.warn("name of connector's source/target does has two parts: instance.port, cannot resolve port");
      return null;
    }
    String instancePort = parts.next();
    Optional<ComponentInstanceSymbol> inst = cmp.getSpannedScope()
        .<ComponentInstanceSymbol>resolveLocally(instance, ComponentInstanceSymbol.KIND);
    if (!inst.isPresent()) {
      Log.warn(String.format("Could not find instance %s in component %s, cannot resolve port", instance, cmp.getFullName()));
      return null;
    }
    port = inst.get().getComponentType().getReferencedSymbol().getSpannedScope()
        .resolveLocally(instancePort, PortSymbol.KIND);
    if (port.isPresent()) {
      return port.get();
    }

    return null;
  }

  /**
   * does not return Optional, since every connector has a port
   * if the model is well-formed
   */
  public PortSymbol getSourcePort() {
    return getPort(this.getSource());
  }

  /**
   * does not return Optional, since every connector has a port
   * if the model is well-formed
   */
  public PortSymbol getTargetPort() {
    return getPort(this.getTarget());
  }

  /**
   * returns the component which defines the connector
   * this is independent from the component to which the source and target ports
   * belong to
   *
   * @return is optional, b/c a connector can belong to a component symbol or to
   * an expanded component instance symbol
   */
  public Optional<ComponentSymbol> getComponent() {
    if (!this.getEnclosingScope().getSpanningSymbol().isPresent()) {
      return Optional.empty();
    }
    if (!(this.getEnclosingScope().getSpanningSymbol().get() instanceof ComponentSymbol)) {
      return Optional.empty();
    }
    return Optional.of((ComponentSymbol) this.getEnclosingScope().getSpanningSymbol().get());
  }

  /**
   * returns the expanded component instance which defines the connector
   * this is independent from the component to which the source and target ports
   * belong to
   *
   * @return is optional, b/c a connector can belong to a component symbol or to
   * an expanded component instance symbol
   */
  public Optional<ExpandedComponentInstanceSymbol> getComponentInstance() {
    if (!this.getEnclosingScope().getSpanningSymbol().isPresent()) {
      return Optional.empty();
    }
    if (!(this.getEnclosingScope().getSpanningSymbol().get() instanceof ExpandedComponentInstanceSymbol)) {
      return Optional.empty();
    }
    return Optional.of((ExpandedComponentInstanceSymbol) this.getEnclosingScope().getSpanningSymbol().get());
  }

  /**
   * @return the target
   */
  public String getTarget() {
    return target;
  }

  /**
   * @param target the target to set
   */
  public void setTarget(String target) {
    this.target = target;
  }

  /**
   * Adds the stereotype key=value to this entry's map of stereotypes
   *
   * @param key      the stereotype's key
   * @param optional the stereotype's value
   */
  public void addStereotype(String key, Optional<String> optional) {
    stereotype.put(key, optional);
  }

  /**
   * Adds the stereotype key=value to this entry's map of stereotypes
   *
   * @param key   the stereotype's key
   * @param value the stereotype's value
   */
  public void addStereotype(String key, @Nullable String value) {
    if (value != null && value.isEmpty()) {
      value = null;
    }
    stereotype.put(key, Optional.ofNullable(value));
  }

  /**
   * @return map representing the stereotype of this component
   */
  public Map<String, Optional<String>> getStereotype() {
    return stereotype;
  }

  @Override
  public String toString() {
    return SymbolPrinter.printConnector(this);
  }

  @Override
  public String getName() {
    return getTarget();
  }

}
