/* generated from model null*/
/* generated by template parser.Parser*/

// Generated antlr file

// Parser header
/* generated by template parser.ParserHeader*/
grammar TagSchemaAntlr;
@parser::header {
package de.monticore.lang.montiarc.tagschema._parser;
import de.monticore.antlr4.MCParser;
}
@lexer::header {
package de.monticore.lang.montiarc.tagschema._parser;
}
options {
superClass=MCParser;
}

@parser::members

{
// Global actions

// Convert functions
  // convert function for Digits
private String convertDigits(Token t)  {
    return t.getText();
}

  // convert function for OctalNumeral
private String convertOctalNumeral(Token t)  {
    return t.getText();
}

  // convert function for String
private String convertString(Token t)  {
    return t.getText();
}

  // convert function for BinaryNumeral
private String convertBinaryNumeral(Token t)  {
    return t.getText();
}

  // convert function for HexDigit
private String convertHexDigit(Token t)  {
    return t.getText();
}

  // convert function for HexIntegerLiteral
private String convertHexIntegerLiteral(Token t)  {
    return t.getText();
}

  // convert function for BinaryDigit
private String convertBinaryDigit(Token t)  {
    return t.getText();
}

  // convert function for BinaryExponentIndicator
private String convertBinaryExponentIndicator(Token t)  {
    return t.getText();
}

  // convert function for OctalEscape
private String convertOctalEscape(Token t)  {
    return t.getText();
}

  // convert function for ExponentIndicator
private String convertExponentIndicator(Token t)  {
    return t.getText();
}

  // convert function for HexadecimalDoublePointLiteral
private String convertHexadecimalDoublePointLiteral(Token t)  {
    return t.getText();
}

  // convert function for IntegerTypeSuffix
private String convertIntegerTypeSuffix(Token t)  {
    return t.getText();
}

  // convert function for Char
private String convertChar(Token t)  {
    return t.getText();
}

  // convert function for BinaryDigits
private String convertBinaryDigits(Token t)  {
    return t.getText();
}

  // convert function for UnicodeEscape
private String convertUnicodeEscape(Token t)  {
    return t.getText();
}

  // convert function for DoubleTypeSuffix
private String convertDoubleTypeSuffix(Token t)  {
    return t.getText();
}

  // convert function for OctalIntegerLiteral
private String convertOctalIntegerLiteral(Token t)  {
    return t.getText();
}

  // convert function for OctalDigit
private String convertOctalDigit(Token t)  {
    return t.getText();
}

  // convert function for OctalDigitOrUnderscore
private String convertOctalDigitOrUnderscore(Token t)  {
    return t.getText();
}

  // convert function for DigitOrUnderscore
private String convertDigitOrUnderscore(Token t)  {
    return t.getText();
}

  // convert function for HexSignificand
private String convertHexSignificand(Token t)  {
    return t.getText();
}

  // convert function for SL_COMMENT
private String convertSL_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for OctalDigits
private String convertOctalDigits(Token t)  {
    return t.getText();
}

  // convert function for Name
private String convertName(Token t)  {
    return t.getText();
}

  // convert function for Num_Int
private String convertNum_Int(Token t)  {
    return t.getText();
}

  // convert function for HexNumeral
private String convertHexNumeral(Token t)  {
    return t.getText();
}

  // convert function for BinaryIntegerLiteral
private String convertBinaryIntegerLiteral(Token t)  {
    return t.getText();
}

  // convert function for Underscores
private String convertUnderscores(Token t)  {
    return t.getText();
}

  // convert function for SingleCharacter
private String convertSingleCharacter(Token t)  {
    return t.getText();
}

  // convert function for NEWLINE
private String convertNEWLINE(Token t)  {
    return t.getText();
}

  // convert function for NonZeroDigit
private String convertNonZeroDigit(Token t)  {
    return t.getText();
}

  // convert function for DecimalIntegerLiteral
private String convertDecimalIntegerLiteral(Token t)  {
    return t.getText();
}

  // convert function for SignedInteger
private String convertSignedInteger(Token t)  {
    return t.getText();
}

  // convert function for StringCharacter
private String convertStringCharacter(Token t)  {
    return t.getText();
}

  // convert function for Num_Double
private String convertNum_Double(Token t)  {
    return t.getText();
}

  // convert function for ZeroToThree
private String convertZeroToThree(Token t)  {
    return t.getText();
}

  // convert function for HexDigits
private String convertHexDigits(Token t)  {
    return t.getText();
}

  // convert function for ExponentPart
private String convertExponentPart(Token t)  {
    return t.getText();
}

  // convert function for Num_Float
private String convertNum_Float(Token t)  {
    return t.getText();
}

  // convert function for FloatTypeSuffix
private String convertFloatTypeSuffix(Token t)  {
    return t.getText();
}

  // convert function for WS
private String convertWS(Token t)  {
    return t.getText();
}

  // convert function for Digit
private String convertDigit(Token t)  {
    return t.getText();
}

  // convert function for StringCharacters
private String convertStringCharacters(Token t)  {
    return t.getText();
}

  // convert function for Num_Long
private String convertNum_Long(Token t)  {
    return t.getText();
}

  // convert function for DecimalNumeral
private String convertDecimalNumeral(Token t)  {
    return t.getText();
}

  // convert function for EscapeSequence
private String convertEscapeSequence(Token t)  {
    return t.getText();
}

  // convert function for HexadecimalFloatingPointLiteral
private String convertHexadecimalFloatingPointLiteral(Token t)  {
    return t.getText();
}

  // convert function for DecimalFloatingPointLiteral
private String convertDecimalFloatingPointLiteral(Token t)  {
    return t.getText();
}

  // convert function for BinaryExponent
private String convertBinaryExponent(Token t)  {
    return t.getText();
}

  // convert function for DecimalDoublePointLiteral
private String convertDecimalDoublePointLiteral(Token t)  {
    return t.getText();
}

  // convert function for HexDigitOrUnderscore
private String convertHexDigitOrUnderscore(Token t)  {
    return t.getText();
}

  // convert function for ML_COMMENT
private String convertML_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for BinaryDigitOrUnderscore
private String convertBinaryDigitOrUnderscore(Token t)  {
    return t.getText();
}

  // convert function for Sign
private String convertSign(Token t)  {
    return t.getText();
}

}

// Lexer header
/* generated by template parser.LexerMember*/


@lexer::members {

// Add additional Java Code to lexer

private de.monticore.antlr4.MCParser _monticore_parser;
protected de.monticore.antlr4.MCParser getCompiler() {
   return _monticore_parser;
}
public void setMCParser(de.monticore.antlr4.MCParser in) {
  this._monticore_parser = in;
}
}


// Global actions

// Parser rules 
  
 // Start of 'ASTClassProd NullLiteral'


nullLiteral_eof returns [de.monticore.literals.literals._ast.ASTNullLiteral ret = null] :
  tmp = nullLiteral {$ret = $tmp.ret;} EOF ;


  nullLiteral returns [de.monticore.literals.literals._ast.ASTNullLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTNullLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTNullLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal null'
('null')// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd BooleanLiteral'


booleanLiteral_eof returns [de.monticore.literals.literals._ast.ASTBooleanLiteral ret = null] :
  tmp = booleanLiteral {$ret = $tmp.ret;} EOF ;


  booleanLiteral returns [de.monticore.literals.literals._ast.ASTBooleanLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTBooleanLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTBooleanLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTConstantGroup'
('true'{
_aNode.setSource(de.monticore.literals.literals._ast.ASTConstantsLiterals.TRUE);
}|
'false'{
_aNode.setSource(de.monticore.literals.literals._ast.ASTConstantsLiterals.FALSE);
})// End of 'ASTConstantGroup'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CharLiteral'


charLiteral_eof returns [de.monticore.literals.literals._ast.ASTCharLiteral ret = null] :
  tmp = charLiteral {$ret = $tmp.ret;} EOF ;


  charLiteral returns [de.monticore.literals.literals._ast.ASTCharLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTCharLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTCharLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Char{_aNode.setSource(convertChar($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd StringLiteral'


stringLiteral_eof returns [de.monticore.literals.literals._ast.ASTStringLiteral ret = null] :
  tmp = stringLiteral {$ret = $tmp.ret;} EOF ;


  stringLiteral returns [de.monticore.literals.literals._ast.ASTStringLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTStringLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTStringLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=String{_aNode.setSource(convertString($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd IntLiteral'


intLiteral_eof returns [de.monticore.literals.literals._ast.ASTIntLiteral ret = null] :
  tmp = intLiteral {$ret = $tmp.ret;} EOF ;


  intLiteral returns [de.monticore.literals.literals._ast.ASTIntLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTIntLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTIntLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : // Adding subrules
  (subRuleVar0 = signedIntLiteral{$ret = $subRuleVar0.ret;}) |  
// end subrules
  
  (tmp0=Num_Int{_aNode.setSource(convertNum_Int($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedIntLiteral'


signedIntLiteral_eof returns [de.monticore.literals.literals._ast.ASTSignedIntLiteral ret = null] :
  tmp = signedIntLiteral {$ret = $tmp.ret;} EOF ;


  signedIntLiteral returns [de.monticore.literals.literals._ast.ASTSignedIntLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTSignedIntLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTSignedIntLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
MINUS{
_aNode.setNegative(true);
}// End of 'ASTConstantGroup'

  
)?
  (tmp0=Num_Int{_aNode.setSource(convertNum_Int($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd LongLiteral'


longLiteral_eof returns [de.monticore.literals.literals._ast.ASTLongLiteral ret = null] :
  tmp = longLiteral {$ret = $tmp.ret;} EOF ;


  longLiteral returns [de.monticore.literals.literals._ast.ASTLongLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTLongLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTLongLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : // Adding subrules
  (subRuleVar0 = signedLongLiteral{$ret = $subRuleVar0.ret;}) |  
// end subrules
  
  (tmp0=Num_Long{_aNode.setSource(convertNum_Long($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedLongLiteral'


signedLongLiteral_eof returns [de.monticore.literals.literals._ast.ASTSignedLongLiteral ret = null] :
  tmp = signedLongLiteral {$ret = $tmp.ret;} EOF ;


  signedLongLiteral returns [de.monticore.literals.literals._ast.ASTSignedLongLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTSignedLongLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTSignedLongLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
MINUS{
_aNode.setNegative(true);
}// End of 'ASTConstantGroup'

  
)?
  (tmp0=Num_Long{_aNode.setSource(convertNum_Long($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd FloatLiteral'


floatLiteral_eof returns [de.monticore.literals.literals._ast.ASTFloatLiteral ret = null] :
  tmp = floatLiteral {$ret = $tmp.ret;} EOF ;


  floatLiteral returns [de.monticore.literals.literals._ast.ASTFloatLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTFloatLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTFloatLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : // Adding subrules
  (subRuleVar0 = signedFloatLiteral{$ret = $subRuleVar0.ret;}) |  
// end subrules
  
  (tmp0=Num_Float{_aNode.setSource(convertNum_Float($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedFloatLiteral'


signedFloatLiteral_eof returns [de.monticore.literals.literals._ast.ASTSignedFloatLiteral ret = null] :
  tmp = signedFloatLiteral {$ret = $tmp.ret;} EOF ;


  signedFloatLiteral returns [de.monticore.literals.literals._ast.ASTSignedFloatLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTSignedFloatLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTSignedFloatLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
MINUS{
_aNode.setNegative(true);
}// End of 'ASTConstantGroup'

  
)?
  (tmp0=Num_Float{_aNode.setSource(convertNum_Float($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd DoubleLiteral'


doubleLiteral_eof returns [de.monticore.literals.literals._ast.ASTDoubleLiteral ret = null] :
  tmp = doubleLiteral {$ret = $tmp.ret;} EOF ;


  doubleLiteral returns [de.monticore.literals.literals._ast.ASTDoubleLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTDoubleLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTDoubleLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : // Adding subrules
  (subRuleVar0 = signedDoubleLiteral{$ret = $subRuleVar0.ret;}) |  
// end subrules
  
  (tmp0=Num_Double{_aNode.setSource(convertNum_Double($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedDoubleLiteral'


signedDoubleLiteral_eof returns [de.monticore.literals.literals._ast.ASTSignedDoubleLiteral ret = null] :
  tmp = signedDoubleLiteral {$ret = $tmp.ret;} EOF ;


  signedDoubleLiteral returns [de.monticore.literals.literals._ast.ASTSignedDoubleLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.literals._ast.ASTSignedDoubleLiteral _aNode = null;
_aNode=de.monticore.literals.literals._ast.LiteralsNodeFactory.createASTSignedDoubleLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
MINUS{
_aNode.setNegative(true);
}// End of 'ASTConstantGroup'

  
)?
  (tmp0=Num_Double{_aNode.setSource(convertNum_Double($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd QualifiedName'


qualifiedName_eof returns [de.monticore.types.types._ast.ASTQualifiedName ret = null] :
  tmp = qualifiedName {$ret = $tmp.ret;} EOF ;


  qualifiedName returns [de.monticore.types.types._ast.ASTQualifiedName ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTQualifiedName _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTQualifiedName();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  (tmp0=Name{ addToIteratedAttributeIfNotNull(_aNode.getParts(), convertName($tmp0));}

  /* Automatically added keywords [null, true, false, void, boolean, byte, short, int, long, char, float, double, extends, super, import, public, private, protected, final, abstract, local, derived, readonly, static, package, tagschema, Component, Port, Connector, ComponentInstance, for, tagtype, String, Boolean] */
   | 
  ('null'{_aNode.getParts().add("null");})
   | 
  ('true'{_aNode.getParts().add("true");})
   | 
  ('false'{_aNode.getParts().add("false");})
   | 
  ('void'{_aNode.getParts().add("void");})
   | 
  ('boolean'{_aNode.getParts().add("boolean");})
   | 
  ('byte'{_aNode.getParts().add("byte");})
   | 
  ('short'{_aNode.getParts().add("short");})
   | 
  ('int'{_aNode.getParts().add("int");})
   | 
  ('long'{_aNode.getParts().add("long");})
   | 
  ('char'{_aNode.getParts().add("char");})
   | 
  ('float'{_aNode.getParts().add("float");})
   | 
  ('double'{_aNode.getParts().add("double");})
   | 
  ('extends'{_aNode.getParts().add("extends");})
   | 
  ('super'{_aNode.getParts().add("super");})
   | 
  ('import'{_aNode.getParts().add("import");})
   | 
  ('public'{_aNode.getParts().add("public");})
   | 
  ('private'{_aNode.getParts().add("private");})
   | 
  ('protected'{_aNode.getParts().add("protected");})
   | 
  ('final'{_aNode.getParts().add("final");})
   | 
  ('abstract'{_aNode.getParts().add("abstract");})
   | 
  ('local'{_aNode.getParts().add("local");})
   | 
  ('derived'{_aNode.getParts().add("derived");})
   | 
  ('readonly'{_aNode.getParts().add("readonly");})
   | 
  ('static'{_aNode.getParts().add("static");})
   | 
  ('package'{_aNode.getParts().add("package");})
   | 
  ('tagschema'{_aNode.getParts().add("tagschema");})
   | 
  ('Component'{_aNode.getParts().add("Component");})
   | 
  ('Port'{_aNode.getParts().add("Port");})
   | 
  ('Connector'{_aNode.getParts().add("Connector");})
   | 
  ('ComponentInstance'{_aNode.getParts().add("ComponentInstance");})
   | 
  ('for'{_aNode.getParts().add("for");})
   | 
  ('tagtype'{_aNode.getParts().add("tagtype");})
   | 
  ('String'{_aNode.getParts().add("String");})
   | 
  ('Boolean'{_aNode.getParts().add("Boolean");})
  ) 
  
  (
  
  
 // Start of 'ASTTerminal .'
(POINT)// End of 'ASTTerminal'

  (tmp1=Name{ addToIteratedAttributeIfNotNull(_aNode.getParts(), convertName($tmp1));}

  /* Automatically added keywords [null, true, false, void, boolean, byte, short, int, long, char, float, double, extends, super, import, public, private, protected, final, abstract, local, derived, readonly, static, package, tagschema, Component, Port, Connector, ComponentInstance, for, tagtype, String, Boolean] */
   | 
  ('null'{_aNode.getParts().add("null");})
   | 
  ('true'{_aNode.getParts().add("true");})
   | 
  ('false'{_aNode.getParts().add("false");})
   | 
  ('void'{_aNode.getParts().add("void");})
   | 
  ('boolean'{_aNode.getParts().add("boolean");})
   | 
  ('byte'{_aNode.getParts().add("byte");})
   | 
  ('short'{_aNode.getParts().add("short");})
   | 
  ('int'{_aNode.getParts().add("int");})
   | 
  ('long'{_aNode.getParts().add("long");})
   | 
  ('char'{_aNode.getParts().add("char");})
   | 
  ('float'{_aNode.getParts().add("float");})
   | 
  ('double'{_aNode.getParts().add("double");})
   | 
  ('extends'{_aNode.getParts().add("extends");})
   | 
  ('super'{_aNode.getParts().add("super");})
   | 
  ('import'{_aNode.getParts().add("import");})
   | 
  ('public'{_aNode.getParts().add("public");})
   | 
  ('private'{_aNode.getParts().add("private");})
   | 
  ('protected'{_aNode.getParts().add("protected");})
   | 
  ('final'{_aNode.getParts().add("final");})
   | 
  ('abstract'{_aNode.getParts().add("abstract");})
   | 
  ('local'{_aNode.getParts().add("local");})
   | 
  ('derived'{_aNode.getParts().add("derived");})
   | 
  ('readonly'{_aNode.getParts().add("readonly");})
   | 
  ('static'{_aNode.getParts().add("static");})
   | 
  ('package'{_aNode.getParts().add("package");})
   | 
  ('tagschema'{_aNode.getParts().add("tagschema");})
   | 
  ('Component'{_aNode.getParts().add("Component");})
   | 
  ('Port'{_aNode.getParts().add("Port");})
   | 
  ('Connector'{_aNode.getParts().add("Connector");})
   | 
  ('ComponentInstance'{_aNode.getParts().add("ComponentInstance");})
   | 
  ('for'{_aNode.getParts().add("for");})
   | 
  ('tagtype'{_aNode.getParts().add("tagtype");})
   | 
  ('String'{_aNode.getParts().add("String");})
   | 
  ('Boolean'{_aNode.getParts().add("Boolean");})
  ) 
  
  
)*
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ComplexArrayType'


complexArrayType_eof returns [de.monticore.types.types._ast.ASTComplexArrayType ret = null] :
  tmp = complexArrayType {$ret = $tmp.ret;} EOF ;


  complexArrayType returns [de.monticore.types.types._ast.ASTComplexArrayType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTComplexArrayType _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTComplexArrayType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=complexReferenceType{_aNode.setComponentType(_localctx.tmp0.ret);}  
  
  (
  
  (
  
  (
  
  
 // Start of 'ASTTerminal ['
(LBRACK)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ]'
(RBRACK)// End of 'ASTTerminal'

  {_aNode.setDimensions(_aNode.getDimensions()+1);
}
  
)+
  
)
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd PrimitiveArrayType'


primitiveArrayType_eof returns [de.monticore.types.types._ast.ASTPrimitiveArrayType ret = null] :
  tmp = primitiveArrayType {$ret = $tmp.ret;} EOF ;


  primitiveArrayType returns [de.monticore.types.types._ast.ASTPrimitiveArrayType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTPrimitiveArrayType _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTPrimitiveArrayType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=primitiveType{_aNode.setComponentType(_localctx.tmp0.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ['
(LBRACK)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ]'
(RBRACK)// End of 'ASTTerminal'

  {_aNode.setDimensions(_aNode.getDimensions()+1);
}
  
)+
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd VoidType'


voidType_eof returns [de.monticore.types.types._ast.ASTVoidType ret = null] :
  tmp = voidType {$ret = $tmp.ret;} EOF ;


  voidType returns [de.monticore.types.types._ast.ASTVoidType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTVoidType _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTVoidType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal void'
('void')// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd PrimitiveType'


primitiveType_eof returns [de.monticore.types.types._ast.ASTPrimitiveType ret = null] :
  tmp = primitiveType {$ret = $tmp.ret;} EOF ;


  primitiveType returns [de.monticore.types.types._ast.ASTPrimitiveType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTPrimitiveType _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTPrimitiveType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTConstantGroup'
('boolean'{
_aNode.setPrimitive(de.monticore.types.types._ast.ASTConstantsTypes.BOOLEAN);
}|
'byte'{
_aNode.setPrimitive(de.monticore.types.types._ast.ASTConstantsTypes.BYTE);
}|
'short'{
_aNode.setPrimitive(de.monticore.types.types._ast.ASTConstantsTypes.SHORT);
}|
'int'{
_aNode.setPrimitive(de.monticore.types.types._ast.ASTConstantsTypes.INT);
}|
'long'{
_aNode.setPrimitive(de.monticore.types.types._ast.ASTConstantsTypes.LONG);
}|
'char'{
_aNode.setPrimitive(de.monticore.types.types._ast.ASTConstantsTypes.CHAR);
}|
'float'{
_aNode.setPrimitive(de.monticore.types.types._ast.ASTConstantsTypes.FLOAT);
}|
'double'{
_aNode.setPrimitive(de.monticore.types.types._ast.ASTConstantsTypes.DOUBLE);
})// End of 'ASTConstantGroup'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SimpleReferenceType'


simpleReferenceType_eof returns [de.monticore.types.types._ast.ASTSimpleReferenceType ret = null] :
  tmp = simpleReferenceType {$ret = $tmp.ret;} EOF ;


  simpleReferenceType returns [de.monticore.types.types._ast.ASTSimpleReferenceType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTSimpleReferenceType _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTSimpleReferenceType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Name{ addToIteratedAttributeIfNotNull(_aNode.getNames(), convertName($tmp0));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal .'
(POINT)// End of 'ASTTerminal'

  (tmp1=Name{ addToIteratedAttributeIfNotNull(_aNode.getNames(), convertName($tmp1));}

  /* Automatically added keywords [null, true, false, void, boolean, byte, short, int, long, char, float, double, extends, super, import, public, private, protected, final, abstract, local, derived, readonly, static, package, tagschema, Component, Port, Connector, ComponentInstance, for, tagtype, String, Boolean] */
   | 
  ('null'{_aNode.getNames().add("null");})
   | 
  ('true'{_aNode.getNames().add("true");})
   | 
  ('false'{_aNode.getNames().add("false");})
   | 
  ('void'{_aNode.getNames().add("void");})
   | 
  ('boolean'{_aNode.getNames().add("boolean");})
   | 
  ('byte'{_aNode.getNames().add("byte");})
   | 
  ('short'{_aNode.getNames().add("short");})
   | 
  ('int'{_aNode.getNames().add("int");})
   | 
  ('long'{_aNode.getNames().add("long");})
   | 
  ('char'{_aNode.getNames().add("char");})
   | 
  ('float'{_aNode.getNames().add("float");})
   | 
  ('double'{_aNode.getNames().add("double");})
   | 
  ('extends'{_aNode.getNames().add("extends");})
   | 
  ('super'{_aNode.getNames().add("super");})
   | 
  ('import'{_aNode.getNames().add("import");})
   | 
  ('public'{_aNode.getNames().add("public");})
   | 
  ('private'{_aNode.getNames().add("private");})
   | 
  ('protected'{_aNode.getNames().add("protected");})
   | 
  ('final'{_aNode.getNames().add("final");})
   | 
  ('abstract'{_aNode.getNames().add("abstract");})
   | 
  ('local'{_aNode.getNames().add("local");})
   | 
  ('derived'{_aNode.getNames().add("derived");})
   | 
  ('readonly'{_aNode.getNames().add("readonly");})
   | 
  ('static'{_aNode.getNames().add("static");})
   | 
  ('package'{_aNode.getNames().add("package");})
   | 
  ('tagschema'{_aNode.getNames().add("tagschema");})
   | 
  ('Component'{_aNode.getNames().add("Component");})
   | 
  ('Port'{_aNode.getNames().add("Port");})
   | 
  ('Connector'{_aNode.getNames().add("Connector");})
   | 
  ('ComponentInstance'{_aNode.getNames().add("ComponentInstance");})
   | 
  ('for'{_aNode.getNames().add("for");})
   | 
  ('tagtype'{_aNode.getNames().add("tagtype");})
   | 
  ('String'{_aNode.getNames().add("String");})
   | 
  ('Boolean'{_aNode.getNames().add("Boolean");})
  ) 
  
  
)*
  (
  
   tmp2=typeArguments{_aNode.setTypeArguments(_localctx.tmp2.ret);}  
  
  
)?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ComplexReferenceType'


complexReferenceType_eof returns [de.monticore.types.types._ast.ASTComplexReferenceType ret = null] :
  tmp = complexReferenceType {$ret = $tmp.ret;} EOF ;


  complexReferenceType returns [de.monticore.types.types._ast.ASTComplexReferenceType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTComplexReferenceType _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTComplexReferenceType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
   tmp0=simpleReferenceType{addToIteratedAttributeIfNotNull(_aNode.getSimpleReferenceTypes(), _localctx.tmp0.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal .'
(POINT)// End of 'ASTTerminal'

   tmp1=simpleReferenceType{addToIteratedAttributeIfNotNull(_aNode.getSimpleReferenceTypes(), _localctx.tmp1.ret);}  
  
  
)*
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd TypeArguments'


typeArguments_eof returns [de.monticore.types.types._ast.ASTTypeArguments ret = null] :
  tmp = typeArguments {$ret = $tmp.ret;} EOF ;


  typeArguments returns [de.monticore.types.types._ast.ASTTypeArguments ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTTypeArguments _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTTypeArguments();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal <'
(LT)// End of 'ASTTerminal'

  (
  
   tmp0=typeArgument{addToIteratedAttributeIfNotNull(_aNode.getTypeArguments(), _localctx.tmp0.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp1=typeArgument{addToIteratedAttributeIfNotNull(_aNode.getTypeArguments(), _localctx.tmp1.ret);}  
  
  
)*
  
)?
  
 // Start of 'ASTTerminal >'
(GT)// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd WildcardType'


wildcardType_eof returns [de.monticore.types.types._ast.ASTWildcardType ret = null] :
  tmp = wildcardType {$ret = $tmp.ret;} EOF ;


  wildcardType returns [de.monticore.types.types._ast.ASTWildcardType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTWildcardType _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTWildcardType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal ?'
(QUESTION)// End of 'ASTTerminal'

  (
  
  (
  
  
 // Start of 'ASTTerminal extends'
('extends')// End of 'ASTTerminal'

   tmp0=type{_aNode.setUpperBound(_localctx.tmp0.ret);}  
  
  
)
  |
  (
  
  
 // Start of 'ASTTerminal super'
('super')// End of 'ASTTerminal'

   tmp1=type{_aNode.setLowerBound(_localctx.tmp1.ret);}  
  
  
)
  
)?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd TypeParameters'


typeParameters_eof returns [de.monticore.types.types._ast.ASTTypeParameters ret = null] :
  tmp = typeParameters {$ret = $tmp.ret;} EOF ;


  typeParameters returns [de.monticore.types.types._ast.ASTTypeParameters ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTTypeParameters _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTTypeParameters();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal <'
(LT)// End of 'ASTTerminal'

  (
  
   tmp0=typeVariableDeclaration{addToIteratedAttributeIfNotNull(_aNode.getTypeVariableDeclarations(), _localctx.tmp0.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp1=typeVariableDeclaration{addToIteratedAttributeIfNotNull(_aNode.getTypeVariableDeclarations(), _localctx.tmp1.ret);}  
  
  
)*
  
)
  
 // Start of 'ASTTerminal >'
(GT)// End of 'ASTTerminal'

  
)?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd TypeVariableDeclaration'


typeVariableDeclaration_eof returns [de.monticore.types.types._ast.ASTTypeVariableDeclaration ret = null] :
  tmp = typeVariableDeclaration {$ret = $tmp.ret;} EOF ;


  typeVariableDeclaration returns [de.monticore.types.types._ast.ASTTypeVariableDeclaration ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTTypeVariableDeclaration _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTTypeVariableDeclaration();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal extends'
('extends')// End of 'ASTTerminal'

  (
  
   tmp1=complexReferenceType{addToIteratedAttributeIfNotNull(_aNode.getUpperBounds(), _localctx.tmp1.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal &'
(AND)// End of 'ASTTerminal'

   tmp2=complexReferenceType{addToIteratedAttributeIfNotNull(_aNode.getUpperBounds(), _localctx.tmp2.ret);}  
  
  
)*
  
)
  
)?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ImportStatement'


importStatement_eof returns [de.monticore.types.types._ast.ASTImportStatement ret = null] :
  tmp = importStatement {$ret = $tmp.ret;} EOF ;


  importStatement returns [de.monticore.types.types._ast.ASTImportStatement ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.types._ast.ASTImportStatement _aNode = null;
_aNode=de.monticore.types.types._ast.TypesNodeFactory.createASTImportStatement();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal import'
('import')// End of 'ASTTerminal'

  (
  
  (tmp0=Name{ addToIteratedAttributeIfNotNull(_aNode.getImportList(), convertName($tmp0));}

  /* Automatically added keywords [null, true, false, void, boolean, byte, short, int, long, char, float, double, extends, super, import, public, private, protected, final, abstract, local, derived, readonly, static, package, tagschema, Component, Port, Connector, ComponentInstance, for, tagtype, String, Boolean] */
   | 
  ('null'{_aNode.getImportList().add("null");})
   | 
  ('true'{_aNode.getImportList().add("true");})
   | 
  ('false'{_aNode.getImportList().add("false");})
   | 
  ('void'{_aNode.getImportList().add("void");})
   | 
  ('boolean'{_aNode.getImportList().add("boolean");})
   | 
  ('byte'{_aNode.getImportList().add("byte");})
   | 
  ('short'{_aNode.getImportList().add("short");})
   | 
  ('int'{_aNode.getImportList().add("int");})
   | 
  ('long'{_aNode.getImportList().add("long");})
   | 
  ('char'{_aNode.getImportList().add("char");})
   | 
  ('float'{_aNode.getImportList().add("float");})
   | 
  ('double'{_aNode.getImportList().add("double");})
   | 
  ('extends'{_aNode.getImportList().add("extends");})
   | 
  ('super'{_aNode.getImportList().add("super");})
   | 
  ('import'{_aNode.getImportList().add("import");})
   | 
  ('public'{_aNode.getImportList().add("public");})
   | 
  ('private'{_aNode.getImportList().add("private");})
   | 
  ('protected'{_aNode.getImportList().add("protected");})
   | 
  ('final'{_aNode.getImportList().add("final");})
   | 
  ('abstract'{_aNode.getImportList().add("abstract");})
   | 
  ('local'{_aNode.getImportList().add("local");})
   | 
  ('derived'{_aNode.getImportList().add("derived");})
   | 
  ('readonly'{_aNode.getImportList().add("readonly");})
   | 
  ('static'{_aNode.getImportList().add("static");})
   | 
  ('package'{_aNode.getImportList().add("package");})
   | 
  ('tagschema'{_aNode.getImportList().add("tagschema");})
   | 
  ('Component'{_aNode.getImportList().add("Component");})
   | 
  ('Port'{_aNode.getImportList().add("Port");})
   | 
  ('Connector'{_aNode.getImportList().add("Connector");})
   | 
  ('ComponentInstance'{_aNode.getImportList().add("ComponentInstance");})
   | 
  ('for'{_aNode.getImportList().add("for");})
   | 
  ('tagtype'{_aNode.getImportList().add("tagtype");})
   | 
  ('String'{_aNode.getImportList().add("String");})
   | 
  ('Boolean'{_aNode.getImportList().add("Boolean");})
  ) 
  
  (
  
  
 // Start of 'ASTTerminal .'
(POINT)// End of 'ASTTerminal'

  (tmp1=Name{ addToIteratedAttributeIfNotNull(_aNode.getImportList(), convertName($tmp1));}

  /* Automatically added keywords [null, true, false, void, boolean, byte, short, int, long, char, float, double, extends, super, import, public, private, protected, final, abstract, local, derived, readonly, static, package, tagschema, Component, Port, Connector, ComponentInstance, for, tagtype, String, Boolean] */
   | 
  ('null'{_aNode.getImportList().add("null");})
   | 
  ('true'{_aNode.getImportList().add("true");})
   | 
  ('false'{_aNode.getImportList().add("false");})
   | 
  ('void'{_aNode.getImportList().add("void");})
   | 
  ('boolean'{_aNode.getImportList().add("boolean");})
   | 
  ('byte'{_aNode.getImportList().add("byte");})
   | 
  ('short'{_aNode.getImportList().add("short");})
   | 
  ('int'{_aNode.getImportList().add("int");})
   | 
  ('long'{_aNode.getImportList().add("long");})
   | 
  ('char'{_aNode.getImportList().add("char");})
   | 
  ('float'{_aNode.getImportList().add("float");})
   | 
  ('double'{_aNode.getImportList().add("double");})
   | 
  ('extends'{_aNode.getImportList().add("extends");})
   | 
  ('super'{_aNode.getImportList().add("super");})
   | 
  ('import'{_aNode.getImportList().add("import");})
   | 
  ('public'{_aNode.getImportList().add("public");})
   | 
  ('private'{_aNode.getImportList().add("private");})
   | 
  ('protected'{_aNode.getImportList().add("protected");})
   | 
  ('final'{_aNode.getImportList().add("final");})
   | 
  ('abstract'{_aNode.getImportList().add("abstract");})
   | 
  ('local'{_aNode.getImportList().add("local");})
   | 
  ('derived'{_aNode.getImportList().add("derived");})
   | 
  ('readonly'{_aNode.getImportList().add("readonly");})
   | 
  ('static'{_aNode.getImportList().add("static");})
   | 
  ('package'{_aNode.getImportList().add("package");})
   | 
  ('tagschema'{_aNode.getImportList().add("tagschema");})
   | 
  ('Component'{_aNode.getImportList().add("Component");})
   | 
  ('Port'{_aNode.getImportList().add("Port");})
   | 
  ('Connector'{_aNode.getImportList().add("Connector");})
   | 
  ('ComponentInstance'{_aNode.getImportList().add("ComponentInstance");})
   | 
  ('for'{_aNode.getImportList().add("for");})
   | 
  ('tagtype'{_aNode.getImportList().add("tagtype");})
   | 
  ('String'{_aNode.getImportList().add("String");})
   | 
  ('Boolean'{_aNode.getImportList().add("Boolean");})
  ) 
  
  
)*
  
)
  (
  
  
 // Start of 'ASTTerminal .'
(POINT)// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
STAR{
_aNode.setStar(true);
}// End of 'ASTConstantGroup'

  
)?
  
 // Start of 'ASTTerminal ;'
(SEMI)// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Stereotype'


stereotype_eof returns [de.monticore.common.common._ast.ASTStereotype ret = null] :
  tmp = stereotype {$ret = $tmp.ret;} EOF ;


  stereotype returns [de.monticore.common.common._ast.ASTStereotype ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.common.common._ast.ASTStereotype _aNode = null;
_aNode=de.monticore.common.common._ast.CommonNodeFactory.createASTStereotype();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal <<'
(LTLT)// End of 'ASTTerminal'

  (
  
   tmp0=stereoValue{addToIteratedAttributeIfNotNull(_aNode.getValues(), _localctx.tmp0.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp1=stereoValue{addToIteratedAttributeIfNotNull(_aNode.getValues(), _localctx.tmp1.ret);}  
  
  
)*
  
)
  
 // Start of 'ASTTerminal >'
(GT)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal >'
(GT)// End of 'ASTTerminal'

  {((_input.LT(-2).getLine()==_input.LT(-1).getLine())&&(_input.LT(-1).getCharPositionInLine()==_input.LT(-2).getCharPositionInLine()+1))}?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd StereoValue'


stereoValue_eof returns [de.monticore.common.common._ast.ASTStereoValue ret = null] :
  tmp = stereoValue {$ret = $tmp.ret;} EOF ;


  stereoValue returns [de.monticore.common.common._ast.ASTStereoValue ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.common.common._ast.ASTStereoValue _aNode = null;
_aNode=de.monticore.common.common._ast.CommonNodeFactory.createASTStereoValue();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  /* Automatically added keywords [null, true, false, void, boolean, byte, short, int, long, char, float, double, extends, super, import, public, private, protected, final, abstract, local, derived, readonly, static, package, tagschema, Component, Port, Connector, ComponentInstance, for, tagtype, String, Boolean] */
   | 
  ('null'{_aNode.setName("null");})
   | 
  ('true'{_aNode.setName("true");})
   | 
  ('false'{_aNode.setName("false");})
   | 
  ('void'{_aNode.setName("void");})
   | 
  ('boolean'{_aNode.setName("boolean");})
   | 
  ('byte'{_aNode.setName("byte");})
   | 
  ('short'{_aNode.setName("short");})
   | 
  ('int'{_aNode.setName("int");})
   | 
  ('long'{_aNode.setName("long");})
   | 
  ('char'{_aNode.setName("char");})
   | 
  ('float'{_aNode.setName("float");})
   | 
  ('double'{_aNode.setName("double");})
   | 
  ('extends'{_aNode.setName("extends");})
   | 
  ('super'{_aNode.setName("super");})
   | 
  ('import'{_aNode.setName("import");})
   | 
  ('public'{_aNode.setName("public");})
   | 
  ('private'{_aNode.setName("private");})
   | 
  ('protected'{_aNode.setName("protected");})
   | 
  ('final'{_aNode.setName("final");})
   | 
  ('abstract'{_aNode.setName("abstract");})
   | 
  ('local'{_aNode.setName("local");})
   | 
  ('derived'{_aNode.setName("derived");})
   | 
  ('readonly'{_aNode.setName("readonly");})
   | 
  ('static'{_aNode.setName("static");})
   | 
  ('package'{_aNode.setName("package");})
   | 
  ('tagschema'{_aNode.setName("tagschema");})
   | 
  ('Component'{_aNode.setName("Component");})
   | 
  ('Port'{_aNode.setName("Port");})
   | 
  ('Connector'{_aNode.setName("Connector");})
   | 
  ('ComponentInstance'{_aNode.setName("ComponentInstance");})
   | 
  ('for'{_aNode.setName("for");})
   | 
  ('tagtype'{_aNode.setName("tagtype");})
   | 
  ('String'{_aNode.setName("String");})
   | 
  ('Boolean'{_aNode.setName("Boolean");})
  ) 
  
  (
  
  
 // Start of 'ASTTerminal ='
(EQUALS)// End of 'ASTTerminal'

  (tmp1=String{_aNode.setSource(convertString($tmp1));}

  ) 
  
  
)?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Cardinality'


cardinality_eof returns [de.monticore.common.common._ast.ASTCardinality ret = null] :
  tmp = cardinality {$ret = $tmp.ret;} EOF ;


  cardinality returns [de.monticore.common.common._ast.ASTCardinality ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.common.common._ast.ASTCardinality _aNode = null;
_aNode=de.monticore.common.common._ast.CommonNodeFactory.createASTCardinality();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal ['
(LBRACK)// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTConstantGroup'
STAR{
_aNode.setMany(true);
}// End of 'ASTConstantGroup'

  {_aNode.setLowerBound(0);
_aNode.setUpperBound(0);
}
  |
   tmp0=intLiteral{_aNode.setLowerBoundLit(_localctx.tmp0.ret);}  
  
  {_aNode.setLowerBound(_aNode.getLowerBoundLit().get().getValue());
_aNode.setUpperBound(_aNode.getLowerBound());
}
  (
  
  
 // Start of 'ASTTerminal ..'
(POINTPOINT)// End of 'ASTTerminal'

  (
  
   tmp1=intLiteral{_aNode.setUpperBoundLit(_localctx.tmp1.ret);}  
  
  (
  
  {_aNode.setUpperBound(_aNode.getUpperBoundLit().get().getValue());
}
  
)
  |
  
 // Start of 'ASTConstantGroup'
STAR{
_aNode.setNoUpperLimit(true);
}// End of 'ASTConstantGroup'

  {_aNode.setUpperBound(0);
}
  
)
  
)?
  
)
  
 // Start of 'ASTTerminal ]'
(RBRACK)// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Completeness'


completeness_eof returns [de.monticore.common.common._ast.ASTCompleteness ret = null] :
  tmp = completeness {$ret = $tmp.ret;} EOF ;


  completeness returns [de.monticore.common.common._ast.ASTCompleteness ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.common.common._ast.ASTCompleteness _aNode = null;
_aNode=de.monticore.common.common._ast.CommonNodeFactory.createASTCompleteness();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTConstantGroup'
'(c)'{
_aNode.setComplete(true);
}// End of 'ASTConstantGroup'

  |
  (
  
  
 // Start of 'ASTTerminal ('
(LPAREN)// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
POINTPOINTPOINT{
_aNode.setIncomplete(true);
}// End of 'ASTConstantGroup'

  
 // Start of 'ASTTerminal )'
(RPAREN)// End of 'ASTTerminal'

  
)
  |
  
 // Start of 'ASTConstantGroup'
LPARENPOINTPOINTPOINTCOMMAPOINTPOINTPOINTRPAREN{
_aNode.setIncomplete(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'(c,c)'{
_aNode.setComplete(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'(...,c)'{
_aNode.setRightComplete(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'(c,...)'{
_aNode.setLeftComplete(true);
}// End of 'ASTConstantGroup'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Modifier'


modifier_eof returns [de.monticore.common.common._ast.ASTModifier ret = null] :
  tmp = modifier {$ret = $tmp.ret;} EOF ;


  modifier returns [de.monticore.common.common._ast.ASTModifier ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.common.common._ast.ASTModifier _aNode = null;
_aNode=de.monticore.common.common._ast.CommonNodeFactory.createASTModifier();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  ( tmp0=stereotype{_aNode.setStereotype(_localctx.tmp0.ret);}) ? 
  
  (
  
  
 // Start of 'ASTConstantGroup'
'public'{
_aNode.setPublic(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
PLUS{
_aNode.setPublic(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'private'{
_aNode.setPrivate(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
MINUS{
_aNode.setPrivate(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'protected'{
_aNode.setProtected(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
HASH{
_aNode.setProtected(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'final'{
_aNode.setFinal(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'abstract'{
_aNode.setAbstract(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'local'{
_aNode.setLocal(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'derived'{
_aNode.setDerived(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
SLASH{
_aNode.setDerived(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'readonly'{
_aNode.setReadonly(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
QUESTION{
_aNode.setReadonly(true);
}// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
'static'{
_aNode.setStatic(true);
}// End of 'ASTConstantGroup'

  
)*
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd TagSchemaUnit'


tagSchemaUnit_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTTagSchemaUnit ret = null] :
  tmp = tagSchemaUnit {$ret = $tmp.ret;} EOF ;


  tagSchemaUnit returns [de.monticore.lang.montiarc.tagschema._ast.ASTTagSchemaUnit ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTTagSchemaUnit _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTTagSchemaUnit();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal package'
('package')// End of 'ASTTerminal'

  (
  
  (tmp0=Name{ addToIteratedAttributeIfNotNull(_aNode.getPackage(), convertName($tmp0));}

  /* Automatically added keywords [null, true, false, void, boolean, byte, short, int, long, char, float, double, extends, super, import, public, private, protected, final, abstract, local, derived, readonly, static, package, tagschema, Component, Port, Connector, ComponentInstance, for, tagtype, String, Boolean] */
   | 
  ('null'{_aNode.getPackage().add("null");})
   | 
  ('true'{_aNode.getPackage().add("true");})
   | 
  ('false'{_aNode.getPackage().add("false");})
   | 
  ('void'{_aNode.getPackage().add("void");})
   | 
  ('boolean'{_aNode.getPackage().add("boolean");})
   | 
  ('byte'{_aNode.getPackage().add("byte");})
   | 
  ('short'{_aNode.getPackage().add("short");})
   | 
  ('int'{_aNode.getPackage().add("int");})
   | 
  ('long'{_aNode.getPackage().add("long");})
   | 
  ('char'{_aNode.getPackage().add("char");})
   | 
  ('float'{_aNode.getPackage().add("float");})
   | 
  ('double'{_aNode.getPackage().add("double");})
   | 
  ('extends'{_aNode.getPackage().add("extends");})
   | 
  ('super'{_aNode.getPackage().add("super");})
   | 
  ('import'{_aNode.getPackage().add("import");})
   | 
  ('public'{_aNode.getPackage().add("public");})
   | 
  ('private'{_aNode.getPackage().add("private");})
   | 
  ('protected'{_aNode.getPackage().add("protected");})
   | 
  ('final'{_aNode.getPackage().add("final");})
   | 
  ('abstract'{_aNode.getPackage().add("abstract");})
   | 
  ('local'{_aNode.getPackage().add("local");})
   | 
  ('derived'{_aNode.getPackage().add("derived");})
   | 
  ('readonly'{_aNode.getPackage().add("readonly");})
   | 
  ('static'{_aNode.getPackage().add("static");})
   | 
  ('package'{_aNode.getPackage().add("package");})
   | 
  ('tagschema'{_aNode.getPackage().add("tagschema");})
   | 
  ('Component'{_aNode.getPackage().add("Component");})
   | 
  ('Port'{_aNode.getPackage().add("Port");})
   | 
  ('Connector'{_aNode.getPackage().add("Connector");})
   | 
  ('ComponentInstance'{_aNode.getPackage().add("ComponentInstance");})
   | 
  ('for'{_aNode.getPackage().add("for");})
   | 
  ('tagtype'{_aNode.getPackage().add("tagtype");})
   | 
  ('String'{_aNode.getPackage().add("String");})
   | 
  ('Boolean'{_aNode.getPackage().add("Boolean");})
  ) 
  
  (
  
  
 // Start of 'ASTTerminal .'
(POINT)// End of 'ASTTerminal'

  (tmp1=Name{ addToIteratedAttributeIfNotNull(_aNode.getPackage(), convertName($tmp1));}

  /* Automatically added keywords [null, true, false, void, boolean, byte, short, int, long, char, float, double, extends, super, import, public, private, protected, final, abstract, local, derived, readonly, static, package, tagschema, Component, Port, Connector, ComponentInstance, for, tagtype, String, Boolean] */
   | 
  ('null'{_aNode.getPackage().add("null");})
   | 
  ('true'{_aNode.getPackage().add("true");})
   | 
  ('false'{_aNode.getPackage().add("false");})
   | 
  ('void'{_aNode.getPackage().add("void");})
   | 
  ('boolean'{_aNode.getPackage().add("boolean");})
   | 
  ('byte'{_aNode.getPackage().add("byte");})
   | 
  ('short'{_aNode.getPackage().add("short");})
   | 
  ('int'{_aNode.getPackage().add("int");})
   | 
  ('long'{_aNode.getPackage().add("long");})
   | 
  ('char'{_aNode.getPackage().add("char");})
   | 
  ('float'{_aNode.getPackage().add("float");})
   | 
  ('double'{_aNode.getPackage().add("double");})
   | 
  ('extends'{_aNode.getPackage().add("extends");})
   | 
  ('super'{_aNode.getPackage().add("super");})
   | 
  ('import'{_aNode.getPackage().add("import");})
   | 
  ('public'{_aNode.getPackage().add("public");})
   | 
  ('private'{_aNode.getPackage().add("private");})
   | 
  ('protected'{_aNode.getPackage().add("protected");})
   | 
  ('final'{_aNode.getPackage().add("final");})
   | 
  ('abstract'{_aNode.getPackage().add("abstract");})
   | 
  ('local'{_aNode.getPackage().add("local");})
   | 
  ('derived'{_aNode.getPackage().add("derived");})
   | 
  ('readonly'{_aNode.getPackage().add("readonly");})
   | 
  ('static'{_aNode.getPackage().add("static");})
   | 
  ('package'{_aNode.getPackage().add("package");})
   | 
  ('tagschema'{_aNode.getPackage().add("tagschema");})
   | 
  ('Component'{_aNode.getPackage().add("Component");})
   | 
  ('Port'{_aNode.getPackage().add("Port");})
   | 
  ('Connector'{_aNode.getPackage().add("Connector");})
   | 
  ('ComponentInstance'{_aNode.getPackage().add("ComponentInstance");})
   | 
  ('for'{_aNode.getPackage().add("for");})
   | 
  ('tagtype'{_aNode.getPackage().add("tagtype");})
   | 
  ('String'{_aNode.getPackage().add("String");})
   | 
  ('Boolean'{_aNode.getPackage().add("Boolean");})
  ) 
  
  
)*
  
)
  
 // Start of 'ASTTerminal ;'
(SEMI)// End of 'ASTTerminal'

  
)?
  (
  
   tmp2=importStatement{addToIteratedAttributeIfNotNull(_aNode.getImportStatements(), _localctx.tmp2.ret);}  
  
  
)*
  
 // Start of 'ASTTerminal tagschema'
('tagschema')// End of 'ASTTerminal'

  (tmp3=Name{_aNode.setName(convertName($tmp3));}

  ) 
  
  
 // Start of 'ASTTerminal {'
(LCURLY)// End of 'ASTTerminal'

  ( tmp4=tagType{addToIteratedAttributeIfNotNull(_aNode.getTagTypes(), _localctx.tmp4.ret);}) + 
  
  
 // Start of 'ASTTerminal }'
(RCURLY)// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ComponentScope'


componentScope_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTComponentScope ret = null] :
  tmp = componentScope {$ret = $tmp.ret;} EOF ;


  componentScope returns [de.monticore.lang.montiarc.tagschema._ast.ASTComponentScope ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTComponentScope _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTComponentScope();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal Component'
('Component')// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd PortScope'


portScope_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTPortScope ret = null] :
  tmp = portScope {$ret = $tmp.ret;} EOF ;


  portScope returns [de.monticore.lang.montiarc.tagschema._ast.ASTPortScope ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTPortScope _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTPortScope();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal Port'
('Port')// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ConnectorScope'


connectorScope_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTConnectorScope ret = null] :
  tmp = connectorScope {$ret = $tmp.ret;} EOF ;


  connectorScope returns [de.monticore.lang.montiarc.tagschema._ast.ASTConnectorScope ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTConnectorScope _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTConnectorScope();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal Connector'
('Connector')// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ComponentInstanceScope'


componentInstanceScope_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTComponentInstanceScope ret = null] :
  tmp = componentInstanceScope {$ret = $tmp.ret;} EOF ;


  componentInstanceScope returns [de.monticore.lang.montiarc.tagschema._ast.ASTComponentInstanceScope ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTComponentInstanceScope _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTComponentInstanceScope();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal ComponentInstance'
('ComponentInstance')// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Scope'


scope_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTScope ret = null] :
  tmp = scope {$ret = $tmp.ret;} EOF ;


  scope returns [de.monticore.lang.montiarc.tagschema._ast.ASTScope ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTScope _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTScope();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal for'
('for')// End of 'ASTTerminal'

  (
  
   tmp0=scopeIdentifier{addToIteratedAttributeIfNotNull(_aNode.getScopeIdentifiers(), _localctx.tmp0.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp1=scopeIdentifier{addToIteratedAttributeIfNotNull(_aNode.getScopeIdentifiers(), _localctx.tmp1.ret);}  
  
  
)*
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SimpleTagType'


simpleTagType_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTSimpleTagType ret = null] :
  tmp = simpleTagType {$ret = $tmp.ret;} EOF ;


  simpleTagType returns [de.monticore.lang.montiarc.tagschema._ast.ASTSimpleTagType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTSimpleTagType _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTSimpleTagType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal private'
('private')// End of 'ASTTerminal'

  
)?
  
 // Start of 'ASTTerminal tagtype'
('tagtype')// End of 'ASTTerminal'

  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  ( tmp1=scope{_aNode.setScope(_localctx.tmp1.ret);}) ? 
  
  
 // Start of 'ASTTerminal ;'
(SEMI)// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd EnumeratedTagType'


enumeratedTagType_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTEnumeratedTagType ret = null] :
  tmp = enumeratedTagType {$ret = $tmp.ret;} EOF ;


  enumeratedTagType returns [de.monticore.lang.montiarc.tagschema._ast.ASTEnumeratedTagType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTEnumeratedTagType _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTEnumeratedTagType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal private'
('private')// End of 'ASTTerminal'

  
)?
  
 // Start of 'ASTTerminal tagtype'
('tagtype')// End of 'ASTTerminal'

  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal :'
(COLON)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal ['
(LBRACK)// End of 'ASTTerminal'

  (
  
  (tmp1=String{ addToIteratedAttributeIfNotNull(_aNode.getStrings(), convertString($tmp1));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal |'
(PIPE)// End of 'ASTTerminal'

  (tmp2=String{ addToIteratedAttributeIfNotNull(_aNode.getStrings(), convertString($tmp2));}

  ) 
  
  
)*
  
)
  
 // Start of 'ASTTerminal ]'
(RBRACK)// End of 'ASTTerminal'

  ( tmp3=scope{_aNode.setScope(_localctx.tmp3.ret);}) ? 
  
  
 // Start of 'ASTTerminal ;'
(SEMI)// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ValuedTagType'


valuedTagType_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTValuedTagType ret = null] :
  tmp = valuedTagType {$ret = $tmp.ret;} EOF ;


  valuedTagType returns [de.monticore.lang.montiarc.tagschema._ast.ASTValuedTagType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTValuedTagType _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTValuedTagType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal private'
('private')// End of 'ASTTerminal'

  
)?
  
 // Start of 'ASTTerminal tagtype'
('tagtype')// End of 'ASTTerminal'

  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal :'
(COLON)// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal int'
('int'{_aNode.setInt("int");})// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal String'
('String'{_aNode.setString("String");})// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal Boolean'
('Boolean'{_aNode.setBoolean("Boolean");})// End of 'ASTTerminal'

  |
  (tmp1=Name{_aNode.setUnitKind(convertName($tmp1));}

  ) 
  
  
)
  ( tmp2=scope{_aNode.setScope(_localctx.tmp2.ret);}) ? 
  
  
 // Start of 'ASTTerminal ;'
(SEMI)// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd ComplexTagType'


complexTagType_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTComplexTagType ret = null] :
  tmp = complexTagType {$ret = $tmp.ret;} EOF ;


  complexTagType returns [de.monticore.lang.montiarc.tagschema._ast.ASTComplexTagType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTComplexTagType _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTComplexTagType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal private'
('private')// End of 'ASTTerminal'

  
)?
  
 // Start of 'ASTTerminal tagtype'
('tagtype')// End of 'ASTTerminal'

  ( tmp0=scope{_aNode.setScope(_localctx.tmp0.ret);}) ? 
  
  
 // Start of 'ASTTerminal {'
(LCURLY)// End of 'ASTTerminal'

  (
  
   tmp1=reference{addToIteratedAttributeIfNotNull(_aNode.getReferences(), _localctx.tmp1.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
(COMMA)// End of 'ASTTerminal'

   tmp2=reference{addToIteratedAttributeIfNotNull(_aNode.getReferences(), _localctx.tmp2.ret);}  
  
  
)*
  
)
  
 // Start of 'ASTTerminal ;'
(SEMI)// End of 'ASTTerminal'

  
 // Start of 'ASTTerminal }'
(RCURLY)// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Reference'


reference_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTReference ret = null] :
  tmp = reference {$ret = $tmp.ret;} EOF ;


  reference returns [de.monticore.lang.montiarc.tagschema._ast.ASTReference ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.lang.montiarc.tagschema._ast.ASTReference _aNode = null;
_aNode=de.monticore.lang.montiarc.tagschema._ast.TagSchemaNodeFactory.createASTReference();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal :'
(COLON)// End of 'ASTTerminal'

  (tmp1=Name{_aNode.setDatatype(convertName($tmp1));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal ?'
(QUESTION)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal +'
(PLUS)// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal *'
(STAR)// End of 'ASTTerminal'

  
)?
  ;
  // End of 'ASTClassProd'


// Extra Rules for Interfaces
  
 // Start of 'Literal'


literal_eof returns [de.monticore.literals.literals._ast.ASTLiteral ret = null] :
  tmp = literal {$ret = $tmp.ret;} EOF ;


  literal returns [de.monticore.literals.literals._ast.ASTLiteral ret]: (
  
  tmp0=nullLiteral
{$ret=$tmp0.ret;}
   | 
  tmp1=booleanLiteral
{$ret=$tmp1.ret;}
   | 
  tmp2=charLiteral
{$ret=$tmp2.ret;}
   | 
  tmp3=stringLiteral
{$ret=$tmp3.ret;}
   | 
  tmp4=numericLiteral
{$ret=$tmp4.ret;}
  );
  
 // Start of 'SignedLiteral'


signedLiteral_eof returns [de.monticore.literals.literals._ast.ASTSignedLiteral ret = null] :
  tmp = signedLiteral {$ret = $tmp.ret;} EOF ;


  signedLiteral returns [de.monticore.literals.literals._ast.ASTSignedLiteral ret]: (
  
  tmp0=nullLiteral
{$ret=$tmp0.ret;}
   | 
  tmp1=booleanLiteral
{$ret=$tmp1.ret;}
   | 
  tmp2=charLiteral
{$ret=$tmp2.ret;}
   | 
  tmp3=stringLiteral
{$ret=$tmp3.ret;}
   | 
  tmp4=signedNumericLiteral
{$ret=$tmp4.ret;}
  );
  
 // Start of 'NumericLiteral'


numericLiteral_eof returns [de.monticore.literals.literals._ast.ASTNumericLiteral ret = null] :
  tmp = numericLiteral {$ret = $tmp.ret;} EOF ;


  numericLiteral returns [de.monticore.literals.literals._ast.ASTNumericLiteral ret]: (
  
  tmp0=intLiteral
{$ret=$tmp0.ret;}
   | 
  tmp1=longLiteral
{$ret=$tmp1.ret;}
   | 
  tmp2=floatLiteral
{$ret=$tmp2.ret;}
   | 
  tmp3=doubleLiteral
{$ret=$tmp3.ret;}
  );
  
 // Start of 'SignedNumericLiteral'


signedNumericLiteral_eof returns [de.monticore.literals.literals._ast.ASTSignedNumericLiteral ret = null] :
  tmp = signedNumericLiteral {$ret = $tmp.ret;} EOF ;


  signedNumericLiteral returns [de.monticore.literals.literals._ast.ASTSignedNumericLiteral ret]: (
  
  tmp0=signedIntLiteral
{$ret=$tmp0.ret;}
   | 
  tmp1=signedLongLiteral
{$ret=$tmp1.ret;}
   | 
  tmp2=signedFloatLiteral
{$ret=$tmp2.ret;}
   | 
  tmp3=signedDoubleLiteral
{$ret=$tmp3.ret;}
  );
  
 // Start of 'Type'


type_eof returns [de.monticore.types.types._ast.ASTType ret = null] :
  tmp = type {$ret = $tmp.ret;} EOF ;


  type returns [de.monticore.types.types._ast.ASTType ret]: (
  
  tmp0=complexArrayType
{$ret=$tmp0.ret;}
   | 
  tmp1=primitiveArrayType
{$ret=$tmp1.ret;}
   | 
  tmp2=primitiveType
{$ret=$tmp2.ret;}
   | 
  tmp3=simpleReferenceType
{$ret=$tmp3.ret;}
   | 
  tmp4=complexReferenceType
{$ret=$tmp4.ret;}
  );
  
 // Start of 'ReferenceType'


referenceType_eof returns [de.monticore.types.types._ast.ASTReferenceType ret = null] :
  tmp = referenceType {$ret = $tmp.ret;} EOF ;


  referenceType returns [de.monticore.types.types._ast.ASTReferenceType ret]: (
  
  tmp0=simpleReferenceType
{$ret=$tmp0.ret;}
   | 
  tmp1=complexReferenceType
{$ret=$tmp1.ret;}
  );
  
 // Start of 'TypeArgument'


typeArgument_eof returns [de.monticore.types.types._ast.ASTTypeArgument ret = null] :
  tmp = typeArgument {$ret = $tmp.ret;} EOF ;


  typeArgument returns [de.monticore.types.types._ast.ASTTypeArgument ret]: (
  
  tmp0=wildcardType
{$ret=$tmp0.ret;}
   | 
  tmp1=type
{$ret=$tmp1.ret;}
  );
  
 // Start of 'ReturnType'


returnType_eof returns [de.monticore.types.types._ast.ASTReturnType ret = null] :
  tmp = returnType {$ret = $tmp.ret;} EOF ;


  returnType returns [de.monticore.types.types._ast.ASTReturnType ret]: (
  
  tmp0=voidType
{$ret=$tmp0.ret;}
   | 
  tmp1=type
{$ret=$tmp1.ret;}
  );
  
 // Start of 'ArrayType'


arrayType_eof returns [de.monticore.types.types._ast.ASTArrayType ret = null] :
  tmp = arrayType {$ret = $tmp.ret;} EOF ;


  arrayType returns [de.monticore.types.types._ast.ASTArrayType ret]: (
  
  tmp0=complexArrayType
{$ret=$tmp0.ret;}
   | 
  tmp1=primitiveArrayType
{$ret=$tmp1.ret;}
  );
  
 // Start of 'TagType'


tagType_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTTagType ret = null] :
  tmp = tagType {$ret = $tmp.ret;} EOF ;


  tagType returns [de.monticore.lang.montiarc.tagschema._ast.ASTTagType ret]: (
  
  tmp0=simpleTagType
{$ret=$tmp0.ret;}
   | 
  tmp1=enumeratedTagType
{$ret=$tmp1.ret;}
   | 
  tmp2=valuedTagType
{$ret=$tmp2.ret;}
   | 
  tmp3=complexTagType
{$ret=$tmp3.ret;}
  );
  
 // Start of 'ScopeIdentifier'


scopeIdentifier_eof returns [de.monticore.lang.montiarc.tagschema._ast.ASTScopeIdentifier ret = null] :
  tmp = scopeIdentifier {$ret = $tmp.ret;} EOF ;


  scopeIdentifier returns [de.monticore.lang.montiarc.tagschema._ast.ASTScopeIdentifier ret]: (
  
  tmp0=componentScope
{$ret=$tmp0.ret;}
   | 
  tmp1=portScope
{$ret=$tmp1.ret;}
   | 
  tmp2=connectorScope
{$ret=$tmp2.ret;}
   | 
  tmp3=componentInstanceScope
{$ret=$tmp3.ret;}
  );
 
// Lexer symbols
  LTLT : '<<';
  POINTPOINT : '..';
  LBRACK : '[';
  RBRACK : ']';
  HASH : '#';
  AND : '&';
  LPARENPOINTPOINTPOINTCOMMAPOINTPOINTPOINTRPAREN : '(...,...)';
  LPAREN : '(';
  RPAREN : ')';
  STAR : '*';
  PLUS : '+';
  COMMA : ',';
  MINUS : '-';
  POINT : '.';
  POINTPOINTPOINT : '...';
  SLASH : '/';
  COLON : ':';
  SEMI : ';';
  LCURLY : '{';
  LT : '<';
  PIPE : '|';
  EQUALS : '=';
  RCURLY : '}';
  GT : '>';
  QUESTION : '?';
 
// Lexer rules 
  
 // Start of 'ASTLexProd Name'
Name 
  
:
  
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NEWLINE'
fragment NEWLINE 
  
:
  
  (
  
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd WS'
WS 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  |
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )
-> channel(HIDDEN);// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SL_COMMENT'
SL_COMMENT 
  
:
  
  '//' 
  (
  
  ~(
  
  '\n' 
  |
  '\r' 
  )

  )
*
  {if (getCompiler()!=null) {
   de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
   de.se_rwth.commons.SourcePosition startPos = new de.se_rwth.commons.SourcePosition(_tokenStartLine, _tokenStartCharPositionInLine);
  _comment.set_SourcePositionStart(startPos);
  _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(startPos, getText()));
  getCompiler().addComment(_comment);
}

}-> channel(HIDDEN);// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ML_COMMENT'
ML_COMMENT 
  
:
  
  '/*' 
  (
  
  {_input.LA(2)!='/'}?
  '*' 
  |
   NEWLINE 
  |
  ~(
  
  '*' 
  |
  '\n' 
  |
  '\r' 
  )

  )
*
  '*/' 
  {if (getCompiler()!=null) {
   de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
   de.se_rwth.commons.SourcePosition startPos = new de.se_rwth.commons.SourcePosition(_tokenStartLine, _tokenStartCharPositionInLine);
  _comment.set_SourcePositionStart(startPos);
  _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(startPos, getText()));
  getCompiler().addComment(_comment);
}

}-> channel(HIDDEN);// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Num_Int'
Num_Int 
  
:
  
   DecimalIntegerLiteral 
  |
   HexIntegerLiteral 
  |
   OctalIntegerLiteral 
  |
   BinaryIntegerLiteral 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Num_Long'
Num_Long 
  
:
  
  (
  
   DecimalIntegerLiteral 
   IntegerTypeSuffix 
  )

  |
  (
  
   HexIntegerLiteral 
   IntegerTypeSuffix 
  )

  |
  (
  
   OctalIntegerLiteral 
   IntegerTypeSuffix 
  )

  |
  (
  
   BinaryIntegerLiteral 
   IntegerTypeSuffix 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd DecimalIntegerLiteral'
fragment DecimalIntegerLiteral 
  
:
  
   DecimalNumeral 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd HexIntegerLiteral'
fragment HexIntegerLiteral 
  
:
  
   HexNumeral 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OctalIntegerLiteral'
fragment OctalIntegerLiteral 
  
:
  
   OctalNumeral 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd BinaryIntegerLiteral'
fragment BinaryIntegerLiteral 
  
:
  
   BinaryNumeral 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd IntegerTypeSuffix'
fragment IntegerTypeSuffix 
  
:
  
  'l' 
  |
  'L' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd DecimalNumeral'
fragment DecimalNumeral 
  
:
  
  '0' 
  |
   NonZeroDigit 
  (
  
  (
  
   Digits 
  )
?
  |
   Underscores 
   Digits 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Digits'
fragment Digits 
  
:
  
   Digit 
  (
  
  (
  
   DigitOrUnderscore 
  )
*
   Digit 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Digit'
fragment Digit 
  
:
  
  '0' 
  |
   NonZeroDigit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NonZeroDigit'
fragment NonZeroDigit 
  
:
  
  '1'..'9'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd DigitOrUnderscore'
fragment DigitOrUnderscore 
  
:
  
   Digit 
  |
  '_' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Underscores'
fragment Underscores 
  
:
  
  (
  '_' 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd HexNumeral'
fragment HexNumeral 
  
:
  
  '0' 
  (
  
  'x' 
  |
  'X' 
  )

   HexDigits 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd HexDigits'
fragment HexDigits 
  
:
  
   HexDigit 
  (
  
  (
  
   HexDigitOrUnderscore 
  )
*
   HexDigit 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd HexDigit'
fragment HexDigit 
  
:
  
  '0'..'9'  
  |
  'a'..'f'  
  |
  'A'..'F'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd HexDigitOrUnderscore'
fragment HexDigitOrUnderscore 
  
:
  
   HexDigit 
  |
  '_' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OctalNumeral'
fragment OctalNumeral 
  
:
  
  '0' 
  (
  
   Underscores 
  )
?
   OctalDigits 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OctalDigits'
fragment OctalDigits 
  
:
  
   OctalDigit 
  (
  
  (
  
   OctalDigitOrUnderscore 
  )
*
   OctalDigit 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OctalDigit'
fragment OctalDigit 
  
:
  
  '0'..'7'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OctalDigitOrUnderscore'
fragment OctalDigitOrUnderscore 
  
:
  
   OctalDigit 
  |
  '_' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd BinaryNumeral'
fragment BinaryNumeral 
  
:
  
  '0' 
  (
  
  'b' 
  |
  'B' 
  )

   BinaryDigits 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd BinaryDigits'
fragment BinaryDigits 
  
:
  
   BinaryDigit 
  (
  
  (
  
   BinaryDigitOrUnderscore 
  )
*
   BinaryDigit 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd BinaryDigit'
fragment BinaryDigit 
  
:
  
  '0' 
  |
  '1' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd BinaryDigitOrUnderscore'
fragment BinaryDigitOrUnderscore 
  
:
  
   BinaryDigit 
  |
  '_' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Num_Float'
Num_Float 
  
:
  
   DecimalFloatingPointLiteral 
  |
   HexadecimalFloatingPointLiteral 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Num_Double'
Num_Double 
  
:
  
   DecimalDoublePointLiteral 
  |
   HexadecimalDoublePointLiteral 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd DecimalDoublePointLiteral'
fragment DecimalDoublePointLiteral 
  
:
  
   Digits 
  '.' 
  (
  
   Digits 
  )
?
  (
  
   ExponentPart 
  )
?
  (
  
   DoubleTypeSuffix 
  )
?
  |
  '.' 
   Digits 
  (
  
   ExponentPart 
  )
?
  (
  
   DoubleTypeSuffix 
  )
?
  |
   Digits 
   ExponentPart 
  (
  
   DoubleTypeSuffix 
  )
?
  |
   Digits 
   DoubleTypeSuffix 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd DecimalFloatingPointLiteral'
fragment DecimalFloatingPointLiteral 
  
:
  
   Digits 
  '.' 
  (
  
   Digits 
  )
?
  (
  
   ExponentPart 
  )
?
  (
  
   FloatTypeSuffix 
  )

  |
  '.' 
   Digits 
  (
  
   ExponentPart 
  )
?
  (
  
   FloatTypeSuffix 
  )

  |
   Digits 
   ExponentPart 
  (
  
   FloatTypeSuffix 
  )

  |
   Digits 
   FloatTypeSuffix 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ExponentPart'
fragment ExponentPart 
  
:
  
   ExponentIndicator 
   SignedInteger 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ExponentIndicator'
fragment ExponentIndicator 
  
:
  
  'e' 
  |
  'E' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SignedInteger'
fragment SignedInteger 
  
:
  
  (
  
   Sign 
  )
?
   Digits 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Sign'
fragment Sign 
  
:
  
  '+' 
  |
  '-' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd FloatTypeSuffix'
fragment FloatTypeSuffix 
  
:
  
  'f' 
  |
  'F' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd DoubleTypeSuffix'
fragment DoubleTypeSuffix 
  
:
  
  'd' 
  |
  'D' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd HexadecimalDoublePointLiteral'
fragment HexadecimalDoublePointLiteral 
  
:
  
   HexSignificand 
   BinaryExponent 
  (
  
   DoubleTypeSuffix 
  )
?
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd HexadecimalFloatingPointLiteral'
fragment HexadecimalFloatingPointLiteral 
  
:
  
   HexSignificand 
   BinaryExponent 
  (
  
   FloatTypeSuffix 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd HexSignificand'
fragment HexSignificand 
  
:
  
   HexNumeral 
  (
  '.' 
  )
?
  |
  '0' 
  (
  
  'x' 
  |
  'X' 
  )

  (
  
   HexDigits 
  )
?
  '.' 
   HexDigits 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd BinaryExponent'
fragment BinaryExponent 
  
:
  
   BinaryExponentIndicator 
   SignedInteger 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd BinaryExponentIndicator'
fragment BinaryExponentIndicator 
  
:
  
  'p' 
  |
  'P' 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Char'
Char 
  
:
  
  '\'' 
  (
  
   SingleCharacter 
  |
   EscapeSequence 
  )

  '\'' 
  {setText(getText().substring(1, getText().length()-1));

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SingleCharacter'
fragment SingleCharacter 
  
:
  
  ~(
  
  '\'' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd String'
String 
  
:
  
  '"' 
  (
  
   StringCharacters 
  )
?
  '"' 
  {setText(getText().substring(1, getText().length()-1));

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd StringCharacters'
fragment StringCharacters 
  
:
  
  (
  
   StringCharacter 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd StringCharacter'
fragment StringCharacter 
  
:
  
  ~(
  
  '"' 
  |
  '\\' 
  )

  |
   EscapeSequence 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd EscapeSequence'
fragment EscapeSequence 
  
:
  
  '\\' 
  (
  
  'b' 
  |
  't' 
  |
  'n' 
  |
  'f' 
  |
  'r' 
  |
  '"' 
  |
  '\'' 
  |
  '\\' 
  )

  |
   OctalEscape 
  |
   UnicodeEscape 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OctalEscape'
fragment OctalEscape 
  
:
  
  '\\' 
   OctalDigit 
  |
  '\\' 
   OctalDigit 
   OctalDigit 
  |
  '\\' 
   ZeroToThree 
   OctalDigit 
   OctalDigit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UnicodeEscape'
fragment UnicodeEscape 
  
:
  
  '\\' 
  'u' 
   HexDigit 
   HexDigit 
   HexDigit 
   HexDigit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ZeroToThree'
fragment ZeroToThree 
  
:
  
  '0'..'3'  
  ;// End of 'ASTLexProd'


