/* (c) https://github.com/MontiCore/monticore */
package montiarc.rte.component;

import montiarc.rte.behavior.IBehavior;
import montiarc.rte.port.IInPort;
import montiarc.rte.port.IOutPort;
import montiarc.rte.port.ITimeAwareInPort;
import montiarc.rte.port.TickPort;
import montiarc.rte.port.TimeAwareOutPort;
import montiarc.rte.port.TimeAwarePortForComposition;
import montiarc.rte.scheduling.Scheduler;

import java.util.List;
import java.util.Set;

/**
 * Provides basic implementation for timed components, especially including message handling:
 * {@link #handleTick()}, {@link #handleMessage(IInPort)} and {@link #handleSyncedTickExecution()}.
 * <br>
 * Timed components should provide logic for the method {@link #handleMessageWithBehavior(IInPort)} to call the
 * behavior for the respective port event.
 * <br>
 * Synced components should provide logic for the method {@link #buildSyncMessage()}, creating a synced input object of
 * type {@code <I>} with the current values of all input ports.
 * <br>
 * For dynamic components with modes, {@link AbstractModeComponent} should be used.
 *
 * @param <I> the type of the synced input message class
 *            (containing a message for every port at the time of a synced tick)
 * @param <B> the class defining the interface of the behavior (accepting tick and message events)
 */
public abstract class AbstractComponent<I, B extends IBehavior<I>> implements IComponent {

  protected final String name;
  protected final TickPort tickPort;
  protected Set<IOutPort<?>> unconnectedOutputs;
  protected final Scheduler scheduler;

  protected boolean isAtomic;
  protected boolean isSync;
  protected B behavior;

  protected AbstractComponent(String name, Scheduler scheduler) {
    this.name = name;
    this.scheduler = scheduler;
    this.tickPort = new TickPort(this, scheduler);
  }

  @Override
  public String getName() {
    return name;
  }

  @Override
  public TickPort getTickPort() {
    return this.tickPort;
  }

  public Scheduler getScheduler() {
    return this.scheduler;
  }

  public B getBehavior() {
    return this.behavior;
  }

  public void run() {
    this.scheduler.run(this);
  }

  public void run(int ticks) {
    this.scheduler.run(this, ticks);
  }

  public void unregisterFromScheduler() {
    this.scheduler.unregister(this);
  }

  public abstract List<ITimeAwareInPort<?>> getAllInPorts();
  public abstract List<TimeAwareOutPort<?>> getAllOutPorts();

  protected void sendTickOnAllOutputs() {
    for (IOutPort<?> outP : this.getAllOutPorts()) {
      outP.sendTick();
    }
  }

  protected void sendTickOnAllUnconnectedOutputs() {
    for (IOutPort<?> outP : this.unconnectedOutputs) {
      outP.sendTick();
    }
  }

  /* generated by template montiarc.generator.ma2jsim.component.init.Init.ftl*/
  @Override
  public void init() {
    if (this.isAtomic) {
      if (behavior != null) {
        behavior.init();
      }
    } else {
      for (IComponent comp : this.getAllSubcomponents()) {
        comp.init();
      }
    }
  }

  @Override
  public void handleTick() {
    if (isSync) {
      handleSyncedTickExecution();
    } else {
      handleEventTickExecution();
    }
  }

  @Override
  public void handleMessage(IInPort<?> p) {
    if (!isAtomic) {
      ((montiarc.rte.port.TimeAwarePortForComposition<?>) p).forwardWithoutRemoval();
    } else if (behavior != null) {
      handleMessageWithBehavior(p);
    }
  }

  protected abstract void handleMessageWithBehavior(IInPort<?> p);

  protected abstract I buildSyncMessage();

  protected void handleSyncedTickExecution() {
    // forward message to sub components / atomic behavior
    if (isAtomic) {
      if (behavior != null) {
        this.behavior.tick(buildSyncMessage());
      }
      sendTickOnAllOutputs();
    } else {
      for (montiarc.rte.port.ITimeAwareInPort<?> inP : getAllInPorts()) {
        // Forward the sync message (if existent) and send a tick afterwards
        if (!inP.isTickBlocked()) {
          ((TimeAwarePortForComposition<?>) inP).forwardWithoutRemoval();  // TODO no downcasting would be better
        }
        ((montiarc.rte.port.IOutPort<?>) inP).sendTick();
      }
      this.sendTickOnAllUnconnectedOutputs();
    }
  }

  protected void handleEventTickExecution() {
    // Forward tick to sub components / behavior
    if (isAtomic) {
      if (behavior != null) {
        behavior.tick(null);
      }
      sendTickOnAllOutputs();
    } else {
      for (ITimeAwareInPort<?> inP : this.getAllInPorts()) {
        ((TimeAwarePortForComposition<?>) inP).forwardWithoutRemoval();
      }
      this.sendTickOnAllUnconnectedOutputs();
    }
  }
}
