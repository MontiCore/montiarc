{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#the-montiarc-architecture-description-language","title":"The MontiArc Architecture Description Language","text":"<p>In MontiArc, architectures are described as component and connector systems in which autonomously acting components  perform computations. Communication between components is regulated by connectors between the components\u2019 interfaces,  which are stable and built up by typed, directed ports. Components are either atomic or composed of connected  subcomponents. Atomic components yield behavior descriptions in the form of embedded time-synchronous port automata  or via integration of handcrafted code. For composed components, the behavior emerges from the behavior of their  subcomponents. </p> <p>\u00a9 https://github.com/MontiCore/monticore</p>"},{"location":"#native-installation","title":"Native installation","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Git (for checking out the project)</li> <li>Gradle 7.5.0 (for building the project)</li> <li>Java 11 (for building and executing the project)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p><pre><code>git clone &lt;link to this Git repository&gt;\n</code></pre> Then enter the newly created folder and do  <pre><code>gradle build\n</code></pre></p> <p>This should build the project. Note, building the project for the first time may take a while. Subsequent builds should be faster.</p> <p>Once the project is built, you can look at the generated source code.  The <code>languages</code> folder contains the language components of MontiArc, more  specifically, their frontend implementation. That is parsers to create abstract syntax trees (ASTs) from textual models, infrastructure to create the symbol  table, context condition checks, transformations, visitors, and a command line  tool that puts everything together.</p> <p>The <code>generators</code> folder contains code generators that translate MontiArc component  models to some general-purpose language. Currently, available are the MontiArc to  Java (MA2Java) and the CD to Java (CD2Pojo, Pojo for Plain Old Java) generators.</p> <p>The <code>applications</code> folder contains some example applications.  Each of them should contain a <code>build/generated-sources</code> subdirectory after building their respective project. </p> <p>Please note that <code>gradle build</code> on the topmost folder builds the whole project.  However, each subproject contains an individual build file.  Executing the build command on a subproject builds everything needed for that  project and then builds the project. See the Gradle Website  for more information about the gradle build tool.</p>"},{"location":"#building-and-running-your-first-application","title":"Building and Running Your First Application","text":"<p>This section guides you through building and executing your first application. We will use the example under <code>application/bumperbot</code>. It consists of only a few components but should showcase the build process.</p> <p>We support building an application via an IDE</p>"},{"location":"#building-and-running-an-application-using-an-ide","title":"Building and Running an Application using an IDE","text":"<p>As MontiArc generates Java code, you can use the same IDE to build both MontiArc  and MontiArc applications. The whole build process can be handled by gradle.  That is, <code>gradle build</code> not only generates Java code from MontiArc component  models, but also compiles the handwritten and generated code, and executes tests.  Extending the build process to construct an executable only requires defining the  main class and setting up the build process to generate an executable.</p>"},{"location":"#tool-documentation","title":"Tool Documentation","text":"<p>The MontiArcTool offers capabilities for processing MontiArc component models. It provides multiple options that can be used as follows:</p> <p><code>java -jar MontiArc.jar [-h] -i &lt;fileName&gt; [-path &lt;p&gt;] [-pp [&lt;file&gt;]] [-s [&lt;file&gt;]]</code></p> <p>where the arguments are:</p> Option Explanation <code>-h, --help</code> Prints the help dialog. <code>-v, --version</code> Prints version information. <code>-i, --input &lt;dirlist&gt;</code> Sets the artifact path of the source files, space separated. <code>-path &lt;dirlist&gt;</code> Sets the artifact path for imported symbols, space separated. <code>-pp, --prettyprint &lt;dir&gt;</code> Prints the AST of the component models to stdout or the specified directory (optional). <code>-s, --symboltable &lt;dir&gt;</code> Serializes and prints the symbol table to stdout or the specified output directory (optional). <p>Exemplary usage:</p> <pre><code>  java -jar MontiArc.jar -h\n  java -jar MontiArc.jar -i application/bumperbot/main/resources\n</code></pre> <p>The MA2JavaTool extends the MontiArcTool with code generating capabilities. It provides the following options in addition to those defined above:</p> Option Explanation <code>-o, --output &lt;dir&gt;</code> Sets the target path for the generated files (optional). <code>-hwc &lt;dir&gt;</code> Sets the artifact path for handwritten code (optional)."},{"location":"#further-information","title":"Further Information","text":"<ul> <li>Project root: MontiCore @github</li> <li>MontiCore documentation</li> <li>List of languages</li> <li>MontiCore Core Grammar Library</li> <li>Best Practices</li> <li>Publications about MBSE and MontiCore</li> <li>Licence definition</li> </ul>"},{"location":"BeginnersGuide/","title":"Beginners Guide","text":"<p>This guide introduces you to modeling with MontiArc. It is especially suited, if you have not worked with MontiArc before. If you just want to review concepts, then look at the dedicated pages. To follow along, also make sure to read Getting Started. It introduces you to available tooling that enables you to verify the correctness of written models.</p>"},{"location":"BeginnersGuide/#basic-model-structure","title":"Basic model structure","text":"<p>Let's start by looking at how to write models: MontiArc models are written in plain text. The content of a model file generally looks like the following:</p> <p><pre><code>package car.userinteraction;\n\nimport car.userinteraction.window.WindowPosition;\n\ncomponent WindowController {\n  // Component content\n}\n</code></pre> The structure is as follows: 1. Models are organized in package structures.    Elements defined in the same package are usually visible to each other.    The first declaration of a model defines in which package the model lays. 2. To use model elements that are defined in other packages, import statements are used.    In the example, we import the <code>WindowPosition</code> type.    We will see later what this means and for what it is used. 3. Every model file contains one top-level component type definition.    The definition starts with the keyword <code>component</code>.     It is followed by the name that is mandatory so that we can refer to the component from other locations within our models. 4. The last syntactic element of the example is a simple comment, declared using double slashes <code>//</code>.    Everything that follows within the same line will be ignored by MontiArc.</p>"},{"location":"BeginnersGuide/#project-file-tree-organization","title":"Project file tree organization","text":"<p>Now that we have seen what the content of the file is, we will investigate the role of the file in the file system structure of the project.</p> <p>The file extension is <code>.arc</code>. The file system path to models must match the packages in which they are defined. For our <code>WindowController</code> example, the location could look like <code>my-project/src/montiarc/car/userinteraction/WindowController.arc</code>. For MontiArc, it is only relevant that the last part of the the path matches the whole package hierarchy (namely, <code>car/userinteraction/WindowController.arc</code>). However, build tools may constrain the rest of the path.</p>"},{"location":"BeginnersGuide/#component-interfaces","title":"Component interfaces","text":"<p>An important concept of MontiArc is that the internals of a component are hidden to its operating environment and regarding the other direction: that the component is agnostic of its operating environment, so that it can be used in various operational scenarios. However, somehow the component has to interact with the environment. Ports are used for that role. Their concept includes the following aspects:</p> <ul> <li>They have predefined directions: Either they are incoming or outgoing.    If a port is incoming, then the owning component uses the port to receive data from its environment.    On the other hand, if the port is outgoing, then the owning component uses the port to send data to its environment.</li> <li>Ports are typed.   The types of a ports constrains what data can be received / sent through them.   Example port types are <code>int</code>, <code>boolean</code>, or <code>WindowPosition</code> (from the example above).   We will look at which types can be used later.</li> <li>Names are assigned to each port so that we can later refer to them and the information flowing through them.</li> </ul>"},{"location":"BeginnersGuide/#example-for-component-interfaces","title":"Example for component interfaces","text":"<p>Let us now look at how we can declare ports for components. As an example, let us assume that we are developing a window motor control system for a car. It gets three different kinds of information from its environment: * Whether a window button is pressed and in which direction, * Whether a finger has been detected within in the gap of the window, * The position of the window.    The controller uses this information to stop the window motor when it has been fully closed or opened to avoid damage to the glass.</p> <p>Based on this information, the window control system should send out a concrete motor control command to the motor.</p> <p>We can model this environment interaction in MontiArc like this: <pre><code>// Package declaration and imports ...\n\ncomponent WindowController {\n  port in WindowPosition position,\n       in WindowButtonMoveEvent buttonEvent,\n       in FingerProtectionOrder fingerProtectionOrder,\n       out WindowMoveAction winMoveAction;\n}\n</code></pre> The declaration of the component's ports is started with the <code>port</code> keyword. It is followed by a comma-separated list that contains the declaration of the individual ports. Every such declaration has the form <code>&lt;direction&gt; &lt;port-type&gt; &lt;port-name&gt;</code>. Note the semicolon ending the port declaration. It is also allowed to split the declaration of all ports into separate statements: <pre><code>// Package declaration and imports ...\n\ncomponent WindowController {\n  port in WindowPosition position;\n  port in WindowButtonMoveEvent buttonEvent;\n\n  port in FingerProtectionOrder fingerProtectionOrder,\n       out WindowMoveAction winMoveAction;\n}\n</code></pre> You may use these different options to structure your component model and group ports into  groups of related functionality. The last example is a bad one in that sense, as the <code>fingerProtectionOrder</code> port is grouped with the <code>winMoveAction</code> port where no direct coherence exists (at least not a stronger one than with the other ports).</p>"},{"location":"BeginnersGuide/#defining-component-behavior-with-automatons","title":"Defining component behavior with automatons","text":"<p>After having looked at the API of a component to its environment, let's explore how we can define how the component internally works: let's define some behavior.</p>"},{"location":"BeginnersGuide/#the-behavior-we-want-to-model","title":"The behavior we want to model","text":"<p>We will work again with the example of the <code>WindowController</code> for which we have already defined the component interface. We want to use this information to implement the following behavior: * If the window button is pressed in the \"up\" direction, the window shall completely close.   One press of the \"up\" button should suffice.   It is not mandatory that the button is held during the whole process. * The process is the same for the opposite direction, opening the window completely once the button is pressed in the \"down\" direction. * The user can cancel the opening / closing process by pressing the window button in the direction that is opposite to the window movement (\"down\" while closing and \"up\" while opening). * When a finger has been detected in an open window gap, than the closing window movement must stop.   The system returns to normal operation only after receiving the signal that the finger left the window gap and consequently receiving a window \"down\" movement signal from the window button. * To order the window motor to move, a movement signal shall be sent constantly during the movement period. * When stopping the window movement, the window motor should once receive the information to stop the movement.</p> <p>Before looking at the behavior implementation of the <code>WindowController</code>, lets look at the port types so that we know how to utilize them in our automaton. We use class-diagram models to define the used types as enumerations. You don't have to understand the class-diagram syntax completely, but it should give you an intuitive understanding of the enum types that we will later use. <pre><code>// Model com/example/window.cd\npackage com.example;\n\nclassdiagram window {\n\n  public enum WindowPosition {\n    OPEN, CLOSED, INBETWEEN;\n  }\n\n  public enum WindowButtonMoveEvent {\n    UP_PRESSED, DOWN_PRESSED;\n  }\n\n  public enum WindowMoveAction {\n    MOVE_UP, MOVE_DOWN, STOP_MOVEMENT;\n  }\n}\n</code></pre> <pre><code>// Model com/example/fingerprotection.cd\npackage com.example;\n\nclassdiagram fingerprotection {\n  public enum FingerProtectionOrder {\n    PROTECT, PROTECTION_OFF;\n  }\n}\n</code></pre></p>"},{"location":"BeginnersGuide/#the-montiarc-model-implemented-with-an-automaton","title":"The MontiArc model implemented with an automaton","text":"<p><pre><code>package com.example.window;\n\n// Types within class diagram \"window\" are in a sub-package called window.\n// As the \"window\" class diagram is in the package \"com.example\", its inner types are\n// in the package com.example.window, and thereby in the same package as the WindowController.\n// Hence, we do not need to import its types. We only need to import the types from the\n// fingerprotection class diagram:\nimport com.example.fingerprotection.FingerProtectionOrder;\n\ncomponent WindowController {\n\n  // In this example we distinguish between \"continuous\" and \"event\" values.\n  // With \"continuous\" we mean that we expect that there is always a value at the given port.\n  // With \"event\" we mean that there is only sometimes a value at that port.\n  //   If an event value is not present at a port, then expressions like PORT_NAME == ...\n  //   will always evaluate to false.\n\n  port in WindowPosition position,  // Continuous value\n       in WindowButtonMoveEvent buttonEvent,  // Event value\n       in FingerProtectionOrder fingerProtectionOrder,  // Event value\n       out WindowMoveAction winMoveAction;  // Continuous values during movement, event value when stopping\n\n  automaton {\n    initial state Closed;\n    state Intermediate;\n    state Open;\n    state Blocked;\n    state UnblockingOnDownSignal;\n\n    state Opening {\n      entry / winMoveAction = WindowMoveAction.MOVE_DOWN;\n      do / winMoveAction = WindowMoveAction.MOVE_DOWN;\n      exit / winMoveAction = WindowMoveAction.STOP_MOVEMENT;\n    };\n\n    state Closing {\n      entry / winMoveAction = WindowMoveAction.MOVE_UP;\n      do / winMoveAction = WindowMoveAction.MOVE_UP;\n      exit / winMoveAction = WindowMoveAction.STOP_MOVEMENT;\n    };\n\n\n    // Blocking the movement in case of a detected finger\n    Open -&gt; Blocked [fingerProtectionOrder == FingerProtectionOrder.PROTECT];\n    Intermediate -&gt; Blocked [fingerProtectionOrder == FingerProtectionOrder.PROTECT];\n    Closing -&gt; Blocked [fingerProtectionOrder == FingerProtectionOrder.PROTECT];\n\n    // Transitioning from closed to open\n    Closed -&gt; Opening [buttonEvent == WindowButtonMoveEvent.DOWN_PRESSED];\n    Opening -&gt; Open [position == WindowPosition.OPEN];\n\n    // Transitioning from opened to closed\n    Open -&gt; Closing [buttonEvent == WindowButtonMoveEvent.UP_PRESSED];\n    Closing -&gt; Closed [position == WindowPosition.CLOSED];\n\n    // Interrupting the window movement\n    Closing -&gt; Intermediate [buttonEvent == WindowButtonMoveEvent.DOWN_PRESSED];\n    Opening -&gt; Intermediate [buttonEvent == WindowButtonMoveEvent.UP_PRESSED];\n\n    // Resuming the window movement\n    Intermediate -&gt; Opening [buttonEvent == WindowButtonMoveEvent.DOWN_PRESSED];\n    Intermediate -&gt; Closing [buttonEvent == WindowButtonMoveEvent.UP_PRESSED];\n\n    // Recovering from finger protection\n    Blocked -&gt; UnblockingOnDownSignal [\n      fingerProtectionOrder == FingerProtectionOrder.PROTECTION_OFF\n    ];\n    UnblockingOnDownSignal -&gt; Open [buttonEvent == WindowButtonMoveEvent.DOWN_PRESSED\n                                    &amp;&amp; position == WindowPosition.OPEN];\n    UnblockingOnDownSignal -&gt; Intermediate [buttonEvent == WindowButtonMoveEvent.DOWN_PRESSED\n                                            &amp;&amp; position != WindowPosition.OPEN];\n  }\n}\n</code></pre> We see that the definition of the automaton is part of the component body, next to the port definitions. It is started with the keyword <code>automaton</code> and its content is defined in a body (<code>{ ... }</code>). The body within the braces contains two major elements: state and transition definitions.</p>"},{"location":"BeginnersGuide/#state-definitions","title":"State definitions","text":"<p>They follow the syntax <code>state &lt;state-name&gt; ;</code>. Furthermore, the state definition can contain the following elements: * Putting <code>initial</code> before the stat declaration marks a state as the one that the component will start in once instantiated. In our case, the component starts, assuming that the window is closed. * We can define actions that are executed   1) once the state is entered (entry actions),   2) once it is left (exit actions), and   3) always when no other transition is taken by the state machine (do actions)</p> <p>These actions are defined within a state body, enclosed by {curly braces} following the state name.   The defined actions are formulated as statements, following <code>entry /</code>, <code>exit /</code>, and <code>do /</code>.   If multiple actions should be executed, then they are wrapped in {curly braces}, creating a statement block. Example:   <pre><code>entry / {\n  foo();\n  bar();\n}\n</code></pre>   In our case, we defined all logic that controls the <code>windowMoveAction</code> using entry / exit / and do actions: When entering and remaining in the <code>Opening</code> / <code>Closing</code> state, the window move action is always sent accordingly.   Moreover, when exiting these states, the information that the window movement should stop is sent once.</p>"},{"location":"BeginnersGuide/#transition-definitions","title":"Transition definitions","text":"<p>They follow the syntax <code>&lt;source-state&gt; -&gt; &lt;target-state&gt; [ &lt;condition&gt; ] (/ &lt;action&gt;;)</code>, even if we have not seen the <code>/ &lt;action&gt;</code> syntax in the example. Important elements of the syntax are: * Within square brackets, one can define the condition under which the transition is triggered.   In our case, we constrain the values of input ports. * One can also define actions that should be executed when the transition is triggered.   While in the example above we defined all the behavior using entry-, do-, and exit-actions, we could alternatively use transition actions the following way:   <pre><code>// excerpt within automaton { ... }:\nClosed -&gt; Opening [buttonEvent == WindowButtonMoveEvent.DOWN_PRESSED] / {\n  winMoveAction = WindowMoveAction.MOVE_DOWN;\n};\n// Self-loop for sending continuous signals\nOpening -&gt; Opening [buttonEvent != WindowButtonMoveEvent.UP_PRESSED] / {\n  winMoveAction = WindowMoveAction.MOVE_DOWN;\n}\nOpening -&gt; Open [position == WindowPosition.OPEN] / {\n  winMoveAction = WindowMoveAction.STOP_MOVEMENT;\n};\n</code></pre>   However, in our example, this has the disadvantage that every transition that ends in the <code>Opening</code> state must also set the <code>winMoveAction</code> to <code>MOVE_DOWN</code> and that every transition exiting the <code>Opening</code> state must set the <code>winMoveAction</code> to <code>STOP_MOVEMENT</code>.   As this is more verbose, we decided to use the entry-, do-, and exit-actions in our example.   Still it is important to know both concepts, as the transition actions can express behavior that entry-, do- and exit-actions can not.</p>"},{"location":"BeginnersGuide/#interacting-with-the-environment-port-values","title":"Interacting with the environment: port values","text":"<p>Moreover, we can generally see that * Values of incoming ports can be read by using their name in an expression, e.g.: <code>buttonEvent == WindowButtonMoveEvent.UP_PRESSED</code>.   In this sense they behave like read-only variables, always with the most recent port value. * Values of outgoing ports can be set by using their name in an assignment expression, e.g.: <code>winMoveAction = WindowMoveAction.MOVE_UP</code>.   In this sense they behave like write-only variables.   Reading form them is not allowed.</p> <p>There are also other methods to define the behavior of components. You can read more about this at [Behavior].</p>"},{"location":"BeginnersGuide/#composing-different-systems-to-a-whole","title":"Composing different systems to a whole","text":"<p>Up until now, we have only seen components isolated from their environment. But MontiArc is a component and connector architecture description language. These languages connect different components together in order to build a whole new system. In MontiArc, this composed system results in a new component. This means that when developing a complex architecture, individual sub systems can be developed independently as components. When it is time to integrate the different sub systems, one just connects the different components that represent the sub systems and thereby derives the overall system. As every component is agnostic of its environment, reusing them is also facilitated.</p>"},{"location":"BeginnersGuide/#the-overall-system-we-want-to-model","title":"The overall system we want to model","text":"<p>Let's see how such a composition can be defined in MontiArc! To this end, let's extend the window control example that we already introduced. To complete the window system, we also need the following components: * A human machine interface that captures information about the state of the window buttons.   A car may have multiple buttons to control the same window (directly at the window, at the drivers seat, and in a remote controller).   This human machine interfaces aggregates all the state of all potential control sources and sends out a single control source to the window controller.   <pre><code>package com.example.hmi;\n\nimport com.example.window.WindowButtonMoveEvent;\n\ncomponent HumanMachineInterface {\n  port out WindowButtonMoveEvent winButtonEvent;\n\n  // The component behavior implementation is not relevant to us.\n  // The same holds for the other components.\n}\n</code></pre> * A finger protection sensor that recognizes whether a finger is in the gap of a window   <pre><code>package com.example.fingerprotection;\n\ncomponent FingerProtectionSensor {\n  port out FingerProtectionOrder order;\n}\n</code></pre> * A window position sensor that recognizes the current state of the window (open, closed, or in between)   <pre><code>package com.example.window;\n\ncomponent WindowPositionSensor {\n  port out WindowPosition winPosition;\n}\n</code></pre> * A window motor that, when prompted, moves the window   <pre><code>package com.example.window;\n\ncomponent WindowMotor {\n  port in WindowMoveAction moveOrder;\n}\n</code></pre> * A status LED icon in the cockpit of the car that gives the user feedback by indicating whether current window movement takes place and in which direction   <pre><code>package com.example.window;\n\ncomponent WindowStatusLED {\n  port in WindowMoveAction moveOrder;\n}\n</code></pre></p>"},{"location":"BeginnersGuide/#the-composition-of-the-sub-systems","title":"The composition of the sub systems","text":"<p>Connecting these systems to the <code>WindowController</code>, creating the overall <code>WindowSystem</code> looks like the following: <pre><code>package com.example.window;\n\nimport com.example.fingerprotection.FingerProtectionSensor;\nimport com.example.hmi.HumanMachineInterface;\n\ncomponent WindowSystem {\n  WindowController controller;\n\n  WindowPositionSensor winPositionSensor;\n  HumanMachineInterface hmi;\n  FingerProtectionSensor fingerSensor;\n\n  winPositionSensor.winPosition -&gt; controller.position;\n  hmi.winButtonEvent -&gt; controller.buttonEvent;\n  fingerSensor.order -&gt; controller.fingerProtectionOrder;\n\n  WindowMotor motor;\n  WindowStatusLED led;\n\n  controller.winMoveAction -&gt; motor.moveOrder;\n  controller.winMoveAction -&gt; led.moveOrder;\n}\n</code></pre></p> <p>The two syntactic elements that we see are instantiations of components that we defined earlier and connectors between ports of the component instances.</p>"},{"location":"BeginnersGuide/#component-instantiations","title":"Component instantiations","text":"<p>When we want to use components that we defined before, we are instantiating them in an object-oriented sense: When we defined components such as <code>WindowController</code> or <code>WindowMotor</code> before, we actually defined component types, blueprints that do not exhibit behavior, but only define it. When we are using components, e.g. as parts of a bigger component, we are instantiating component types. Such an instantiation follows the syntax <code>&lt;component-type-name&gt; &lt;instance-name&gt; ;</code>. We are using the instance names later to establish connections among their ports. In accordance with object-orientation, component instances are independent from each other, even if they are of the same type. E.g., a car may have multiple <code>WindowSystem</code>s operating independently from each other: <pre><code>component Car {\n  WindowSystem winFrontLeft;\n  WindowSystem winFrontRight;\n  WindowSystem winBackLeft, winBackRight;\n}\n</code></pre> This example also highlights that multiple instances of the same type can be declared within a single statement, comma-separated.</p> <p>Note that components types that are defined within the same package can be used without further ado. If one wants to use component types from other packages, one has to import them at the beginning of a model. This is exemplified by the <code>WindowSystem</code> importing <code>HumanMachineInterface</code> and <code>FingerProtectionSensor</code>.</p>"},{"location":"BeginnersGuide/#connectors","title":"Connectors","text":"<p>After having declared the component instances that one wants to use, one connects their ports with connectors through which information flows. The syntax of of a connector declaration is <code>&lt;source-instance-name&gt;.&lt;port-name&gt; -&gt; &lt;target-instance-name&gt;.&lt;port-name&gt; ;</code>. Information that the source component sends through a port travels through the attached connector and becomes the input of the declared port of the target component. For example, take the declaration <code>fingerSensor.order -&gt; controller.fingerProtectionOrder;</code> within <code>WindowSystem</code>: The finger detection sensor has some internal logic that at some point detects a finger in the window gap. It then sends the instruction through its outgoing <code>order</code>-port that the window shall be locked. This information (a port value of <code>FingerProtectionOrder.PROTECT</code>) becomes the new current value at the <code>fingerProtectionOrder</code>-port of the window controller. This information can then be used in the behavior implementation of the window controller.</p> <p>If one connects component instances, then there are some restrictions on what ports can be connected: * The source port of the connection must be an outgoing port; * The target port of the connection must be an incoming port; * The target port's type must be of the same type or a super-type of the source port's type.   This is important to guarantee that only data with the correct type is arriving at the target port. * An incoming port of any component instance can only be connected to exactly one source port.   On the other side, an outgoing port can be connected to multiple target ports.   We can see this in the composition of the <code>WindowSystem</code>:   <pre><code>controller.winMoveAction -&gt; motor.moveOrder;\ncontroller.winMoveAction -&gt; led.moveOrder;\n</code></pre>   The <code>winMoveAction</code>-Port of the window controller is connected to both the window motor, as well as a reporting window-movement status LED.</p>"},{"location":"BeginnersGuide/#connectors-among-external-and-internal-ports","title":"Connectors among external and internal ports","text":"<p>The <code>WindowSystem</code> that we have investigated is an isolated system: It is a composition without ports to the outside. However this is not a constraint: Decomposed components can also have ports to the outside. E.g., when deploying multiple window systems in a car, the LEDs that indicate window movement of the individual windows may be bundled into a central display in the cockpit that is not part of the window system itself anymore. Such a change to the window system could look like the following: <pre><code>package com.example.window;\n\nimport com.example.fingerprotection.FingerProtectionSensor;\nimport com.example.hmi.HumanMachineInterface;\n\ncomponent WindowSystem {\n  // The information\n  port out WindowMoveAction currentMovement;\n\n  WindowController controller;\n\n  // No more LED component in the WindowSystem!\n\n  WindowPositionSensor winPositionSensor;\n  HumanMachineInterface hmi;\n  FingerProtectionSensor fingerSensor;\n\n  winPositionSensor.winPosition -&gt; controller.position;\n  hmi.winButtonEvent -&gt; controller.buttonEvent;\n  fingerSensor.order -&gt; controller.fingerProtectionOrder;\n\n  WindowMotor motor;\n  controller.winMoveAction -&gt; motor.moveOrder;\n\n  // There isn't any connection to the led anymore,\n  // but to the outgoing 'currentMovement' port instead:\n  controller.winMoveAction -&gt; currentMovement; \n}\n</code></pre></p> <p>The embedding of such a window system into a car could look like the following: <pre><code>component Car {\n  WindowSystem winFrontLeft, winFrontRight, winBackLeft, winBackRight;\n  CockpitDisplay display;\n\n  winFrontLeft.currentMovement -&gt; display.winFrontLeftMovement;\n  winFrontRight.currentMovement -&gt; display.winFrontRightMovement;\n  winBackLeft.currentMovement -&gt; display.winBackLeftMovement;\n  winBackRight.currentMovement -&gt; display.winBackRightMovement;\n\n  // More car stuff\n}\n</code></pre></p> <p>The changes we made to the <code>WindowSystem</code> are * We have a new outgoing port <code>currentMovement</code> * A connector from the controller port that dictates the window movement to the <code>currentMovement</code> port.   As the <code>currentMovement</code> port is owned by the component type (<code>WindowSystem</code>) but not any sub component, we do not reference it with a preceding instance name within the connector declaration: <code>controller.winMoveAction -&gt; currentMovement</code>.</p> <p>There are new directional constraints when \"outer\" ports of component types are part of a connector: * Incoming ports of component types may only play a role as source ports in connectors, connecting to   * incoming ports of component instances or   * outgoing ports of component types; * Outgoing ports of component types may only play a role as target ports in connectors, connecting to   * outgoing ports of component instances, or   * incoming ports of component types.</p>"},{"location":"BeginnersGuide/#conclusion","title":"Conclusion","text":"<p>This is the end of the beginner's guide. We have seen how to define components and their interfaces through which they interact with their environment. Then we have seen, how we can define behavior of components using automatons. At the end, we have seen how we can compose components to bigger systems which themselves turn out to be components! If you want to learn more, there look at other ways to define behavior, or advanced ways in the definition of component types, such as configuring them during initialization with type or value parameters. </p>"},{"location":"BeginnersGuide/#references","title":"References","text":"<p>The running example of the window control system is based on the following case study:\\ Lity, S., Lachmann, R., Lochau, M., &amp; Schaefer, I. (2013). Delta-oriented software product line test models-the body comfort system case study. Technical report, TU Braunschweig.</p>"},{"location":"Behavior/","title":"Overview","text":"<p>The behavior of a component is formally defined as the function that determines the output value of a component, based on current and historic input values of the component.  There are different ways to describe the behavior of components:</p> <ul> <li>At the heart are expression that allow calculating new output values on the basis of input values.</li> <li>automatons that define state-based behavior with finite state machines</li> <li>imperative code blocks that facilitate algorithm-based behavior programming</li> <li>Additionally, variables may be used to persist state as time progresses</li> </ul> <p>A second aspect of behavior definitions is the timing of when components' input values are evaluated and when output values are calculated based on them. This is especially important when multiple components are composed to a new one: Do they always calculate the next output values at the same time, or independent of each other? MontiArc developers will define which timing paradigm each component implements to answer this question.</p>"},{"location":"Component/","title":"Overview","text":"<p><pre><code>package com.example;\n\n// Top-level component type definition\ncomponent MyComp {\n\n  // Nested component type definition\n  component Foo {\n    // ...\n  }\n\n}\n</code></pre> Component types can be defined * at the top level of a model file or * within the body of other components as nested component types.   However, nested component types can only be used within the context in which they are defined.   In the example above, component type <code>Foo</code> could only be used within <code>MyComp</code>.</p>"},{"location":"Component/#complete-syntax","title":"Complete syntax","text":"<p><pre><code>component &lt;name&gt; (&lt;type-parameters&gt;) (&lt;configuration-parameters&gt;) (extends &lt;parent-component&gt;) {\n  // Component body\n}\n</code></pre> Example: <pre><code>component AgeCategorizer &lt;K, V extends Person&gt; (double classSize, Rule&lt;K, V&gt; rule)\n  extends BiProcessor&lt;K, V&gt; (rule) {\n  // Component body\n}\n</code></pre></p>"},{"location":"TypeSystem/","title":"Overview","text":"<p>MontiArc has a rich static type system to define the structure of data that  flows through ports or is assignable to configuration paramaters, fields,  or other behavioral entities. These types are not definable within MontiArc itself. Instead,</p> <ul> <li>inbuilt primitive types.</li> <li>richer object oriented types can be defined by using class-diagrams.</li> <li>moreover, one can use import java types.</li> </ul> <p>Generics types are also supported as part of object oriented types.</p>"},{"location":"behavior/Automata/","title":"Automata","text":"<p><pre><code>component PedestrianCrossing {\n  port in boolean carDetected,\n         in ButtonEvent pedestrianCrossingRequest,\n       out Color carTrafficLightColor,\n       out Color pedestrianTrafficLightColor;\n\n  automaton {\n\n    initial / {\n      carTrafficLightColor = Color.RED;\n      pedestrianTrafficLightColor = Color.RED;\n    } state CarsPass {\n      entry / {\n        carTrafficLightColor = Color.GREEN;\n        pedestrianTrafficLightColor = Color.RED;\n      }\n      do / {\n        carTrafficLightColor = Color.GREEN;\n        pedestrianTrafficLightColor = Color.RED;\n      }\n    };\n\n    state PassengersPass {\n      entry / {\n        pedestrianTrafficLightColor = Color.GREEN;\n        carTrafficLightColor = Color.RED;\n      }\n      do / {\n        pedestrianTrafficLightColor = Color.GREEN;\n        carTrafficLightColor = Color.RED;\n      }\n    }; \n  }\n\n  CarPass -&gt; PassengerPass [!carDetected &amp;&amp; pedestrianCrossingRequest == ButtonEvent.PRESSED];\n  PassengerPass -&gt; CarPass [carDetected];    \n}\n</code></pre> Automatons allow the description of state-based behavior. One can declare actions to be executed when a state is entered, while it is  maintained, when it is left, or when specific transitions are taken. Moreover, one can define initially executed behavior in the initial state  declaration between the <code>initial</code> keyword and the initial state name.</p>"},{"location":"behavior/Compute/","title":"Compute","text":"<p><pre><code>component FahrenheitToCelsiusAndKelvinConverter {\n  port in double fahrenheit,\n       out double celsius,\n       out double kelvin;\n\n  init {\n    kelvin = 0;\n    celsius = -273.15;  // Equivalent to 0 \u00b0K\n  }\n\n  compute {\n    celsius = (fahrenheit - 32) * 5.0 / 9.0;\n    kelvin = (fahrenheit + 495.67) * 5.0 / 9.0;\n  }\n}\n</code></pre> When using imperative behavior, one can declare the calculation of outgoing  port values by using blocks of arbitrary statements. These statements are declared within the <code>compute</code> block. Moreover, one can define initial outgoing values and other calculations within  the <code>init</code> block, which is especially relevant when using synchronous behavior.</p>"},{"location":"behavior/Operators/","title":"Operators","text":"<p>This page subsumes all available operators that are used to calculate new values from other ones.</p> <p>Table of contents: {{&lt; toc format=html &gt;}}</p>"},{"location":"behavior/Operators/#arithmetic-operators","title":"Arithmetic operators","text":"<p>Where operands and results are both numeric. Note that char is also considered a numeric type. | Operator(s) | Description | |-------------|-------------| | <code>a + b</code> | Addition | | <code>a - b</code> | Subtraction | | <code>a * b</code> | Multiplication | | <code>a / b</code> | Division. If both operands a and b are integer types, then the result is rounded down to the next integer number. | | <code>a % b</code> | Modulo | | <code>+a</code> | Positive prefix (does not change the value) | | <code>-a</code> | Negative prefix (same as <code>-1 * a</code>) | | <code>~a</code> | Bitwise complement of a numeric number | | <code>&amp;a</code> | Bitwise AND | | <code>^a</code> | Bitwise XOR | | <code>\\|a</code> | Bitwise OR |   | <code>a &lt;&lt; n</code> | Signed binary left shift of <code>a</code> by <code>n</code> bits (the sign of the number is preserved, the operation is equivalent with a multiplication by 2^n) | | <code>a &gt;&gt; n</code> | Signed binary right shift of <code>a</code> by <code>n</code> bits (the sign of the number is preserved, the operation is equivalent with a division by 2^n) | | <code>a &gt;&gt;&gt; n</code> | Unsigned binary right shift of <code>a</code> by <code>n</code> bits (the sign bit is not preserved and the number is padded with 0s) |</p> <p>Note that if there is only one operand or if both operands are of the same type, then the result of the operation has the same type. Else, the result is of the wider type. The following is a ranking of the wideness of numeric types: 1. double 2. float 3. long 4. int 5. char</p>"},{"location":"behavior/Operators/#boolean-operators","title":"Boolean operators","text":"<p>Where operands and results are both boolean. | Operator(s) | Description | |-------------|-------------| | <code>!a</code> | Negates the boolean value <code>a</code> | | <code>a &amp; b</code> | Logical AND operation, evaluating both expressions <code>a</code> and <code>b</code> | | <code>a &amp;&amp; b</code> | Shortcutted logical AND operation: If <code>a</code> already evaluates to <code>false</code>, then <code>b</code> is not evaluated. | | <code>a \\| b</code> | Logical OR operation, evaluating both expressions <code>a</code> and <code>b</code> | | <code>a \\|\\| b</code> | Shortcutted logical OR operation: If <code>a</code> already evaluates to <code>true</code>, then <code>b</code> is not evaluated.  |</p>"},{"location":"behavior/Operators/#general-comparison-operators","title":"General comparison operators","text":"Operator(s) Description <code>a == b</code> Test for equality <code>a != b</code> Test for inequality <p>Note that for primitive types equality is based on the equality of their values. For object oriented types, the equality test is based on whether the operands have the reference to the same object.</p>"},{"location":"behavior/Operators/#numeric-comparison-operators","title":"Numeric comparison operators","text":"<p>Where operands are numeric and the result is boolean | Operator(s) | Description | |-------------|-------------| | <code>a &lt; b</code> | Test whether <code>a</code> is smaller than <code>b</code> | | <code>a &lt;= b</code> | Test whether <code>a</code> is smaller or equal to <code>b</code> | | <code>a &gt; b</code> | Test whether <code>a</code> is bigger than <code>b</code> | | <code>a &gt;= b</code> | Test whether <code>a</code> is bigger or equal to <code>b</code> |</p>"},{"location":"behavior/Operators/#field-value-manipulating-operators","title":"Field value manipulating operators","text":"Operator(s) Description <code>++a</code> Increases the value of <code>a</code> by one and then returns <code>a</code>'s new value. <code>--a</code> Decreases the value of <code>a</code> by one and then returns <code>a</code>'s new value. <code>a++</code> Increases the value of <code>a</code> by one, but returns its old value (before the increase). <code>a--</code> Decreases the value of <code>a</code> by one, but returns its old value (before the decrease). <code>a = b</code> <code>b</code>'s value is assigned to <code>a</code> and then <code>a</code>'s new value is returned. <code>a += b</code> Assigns the result of  <code>a + b</code> to <code>a</code> and returns <code>a</code>'s new value. <code>a -= b</code> Assigns the result of  <code>a - b</code> to <code>a</code> and returns <code>a</code>'s new value. <code>a *= b</code> Assigns the result of  <code>a * b</code> to <code>a</code> and returns <code>a</code>'s new value. <code>a /= b</code> Assigns the result of  <code>a / b</code> to <code>a</code> and returns <code>a</code>'s new value. <code>a %= b</code> Assigns the result of  <code>a % b</code> to <code>a</code> and returns <code>a</code>'s new value. <code>a &amp;= b</code> Assigns the result of  <code>a &amp; b</code> to <code>a</code> and returns <code>a</code>'s new value. <code>a \\|= b</code> Assigns the result of  <code>a \\| b</code> to <code>a</code> and returns <code>a</code>'s new value. <code>a ^= b</code> Assigns the result of  <code>a ^ b</code> to <code>a</code> and returns <code>a</code>'s new value. <code>a &lt;&lt;= b</code> Assigns the result of  <code>a &lt;&lt; b</code> to <code>a</code> and returns <code>a</code>'s new value. <code>a &gt;&gt;= b</code> Assigns the result of  <code>a &gt;&gt; b</code> to <code>a</code> and returns <code>a</code>'s new value. <code>a &gt;&gt;&gt;= b</code> Assigns the result of  <code>a &gt;&gt;&gt; b</code> to <code>a</code> and returns <code>a</code>'s new value. <p>Note that these operations are illegal on ports, as incoming ports are read-only and outgoing ports are write-only.</p>"},{"location":"behavior/Operators/#other-operators","title":"Other operators","text":"Operator(s) Description <code>\"Hello\" + \" \" + \"World\"</code> String concatenation (if Strings are available, e.g. by using [class2mc]) <code>foo.someField</code> Access to the field <code>someField</code> of the object <code>foo</code> (given that <code>someField</code> exists in <code>foo</code>) <code>foo.someMethod(arg1, arg2)</code> Method call to <code>someMethod</code> of the object <code>foo</code> (given that <code>someMethod</code> exists in <code>foo</code>) <code>booleanExpr ? a : b</code> If <code>booleanExpr</code> evaluates to <code>true</code>, then <code>a</code> is evaluated and its value is returned. If <code>booleanExpr</code> evaluates to <code>false</code>, then <code>b</code> is evaluated and its value is returned. <code>(a)</code> Bracket expression that just returns <code>a</code>. This expression is used to set the evaluation order of composed expressions: <code>(a + b) * c</code> is evaluated as c times the sum of a and b, while <code>a + b * c</code> is evaluated as a added to the product of b and c."},{"location":"behavior/Statements/","title":"Statements","text":"<p>This page summarizes the available statements in MontiArc. Note that the are not available everywhere (e.g. they are not allowed directly  in component bodies), but usually where behavior is defined.</p>"},{"location":"behavior/Statements/#operational-statements","title":"Operational statements","text":""},{"location":"behavior/Statements/#variable-declarations","title":"Variable declarations","text":"<p><pre><code>DataType varName;\nDataType varName = initValue;\nDataType var1Name, varName2 = initVal, varName3;\n</code></pre> Variables are declared by first defining their type and then creating a name for them. Usually, one assigns an initial value to the variable, but this is optional. Moreover, one can define multiple variables of the same type within the same  statement, separating them with commas.</p>"},{"location":"behavior/Statements/#expression-statements","title":"Expression statements","text":"<p><pre><code>x = 14;\nfoo.callToAMethod();\n</code></pre> One can always use an expression as a statement. Thus, assignments can be declared (which are formally expressions) and methods can be called.</p>"},{"location":"behavior/Statements/#statement-block","title":"Statement block","text":"<p><pre><code>x = 15;\n{\n  int y = 13;\n  foo.someMethodCall();\n}\n</code></pre> Statement blocks can be used to structure code. Usually they are used to structure control statements. On the other side, one can instead use single statements, such as <pre><code>if (condition) thenStatement;\nelse elseStatement;\n</code></pre> but this is discouraged.</p>"},{"location":"behavior/Statements/#empty-statement","title":"Empty statement","text":"<p><pre><code>;\n</code></pre> It is possible to use the semicolon as a statement to signify that nothing should be done as part of the statement.</p>"},{"location":"behavior/Statements/#control-statements","title":"Control statements","text":""},{"location":"behavior/Statements/#if-else","title":"If-else","text":"<pre><code>if (condition) {\n  // Statements\n} else {\n  // Statements\n}\n</code></pre>"},{"location":"behavior/Statements/#while-loop","title":"While loop","text":"<pre><code>while (condition) {\n  // Statements\n}\n</code></pre>"},{"location":"behavior/Statements/#do-while-loop","title":"Do-while loop","text":"<p><pre><code>do {\n  // Statements\n} while (condition)\n</code></pre> First executes the statements block following the <code>do</code>. After each execution of the statement block, the condition is evaluated. If it evaluates to <code>true</code>, then the statement block is executed again.</p>"},{"location":"behavior/Statements/#for-loop","title":"For loop","text":"<p>There are three different versions of the for loop. <pre><code>// Creating control variables:\nfor (int i = expr, j = expr; condition; i++, j--) {\n  // Statements\n}\n</code></pre> First, new variables are created. The condition that decides whether the next round of the loop should be executed is declared following a semicolon. After another semicolon, expressions are defined that are executed at the end of each loop.</p> <p><pre><code>// Initializing existing control variables\nfor (i = expr, j = expr; condition; i++, j--) {\n  // Statements\n}\n</code></pre> Same as before, but the control variables already exist.</p> <p><pre><code>// For-iteration\nfor (int val : IntCollection) {\n  // Statements\n}\n</code></pre> Iterating over a collection of items.</p>"},{"location":"behavior/Statements/#switch","title":"Switch","text":"<p><pre><code>switch (expression) {\n  case CONSTANT_OR_ENUM_VAL: /* statements */ break;\n  default: /* statements */ break;\n}\n</code></pre> evaluates the expression and depending on whether it is equal to a constant or  enumeration value, it executes the statements declared within the respective cases. These statement definitions must be terminated with a <code>break;</code> statement. The statements of the <code>default</code> case are executed if the evaluated expression  value does not match any other case.</p>"},{"location":"behavior/Statements/#break","title":"break","text":"<p>The <code>break;</code> statement is not only available in <code>switch</code>es, but also in loops in  which they terminate the loop early.</p>"},{"location":"behavior/Variables/","title":"Variables","text":"<pre><code>component MovingAverageSmoother {\n  port in double roughSignal,\n       out double smoothedSignal;\n\n  // Declaring fields to save the most recent values\n  double oldestVal = 0.0;\n  double olderVal = 0.0;\n  double youngerVal = 0.0;\n  double youngestVal = 0.0;\n\n  compute {\n    double average = (oldestVal + olderVal + youngerVal + youngestVal + roughSignal) / 5.0;\n\n    // Updating the history values\n    oldestVal = olderVal;\n    olderVal = youngerVal;\n    youngerVal = youngestVal; \n    youngestVal = roughSignal;\n\n    // Sending the smoothed value through the out port\n    smoothedSignal = average;\n  }\n}\n</code></pre> <p>Components may contain internal variables to record state that is maintained  across individual execution steps. Variables are declared directly within the component body with the syntax  <code>&lt;var-type&gt; &lt;var-name&gt; = &lt;initial-value&gt; ;</code>. It is mandatory to assign initial values to all variables. One can also declare multiple variables of the same type within the same  declaration by separating them with commas: <pre><code>component MovingAverageSmoother {\n  // ...\n  double oldestVal = 0.0, olderVal = 0.0, youngerVal = 0.0, youngestVal = 0.0;\n  // ...\n}\n</code></pre></p>"},{"location":"component/Decomposition/","title":"Decomposition","text":"<p><pre><code>component WindowSystem {\n  port in WindowButtonMoveEvent windowCommand;\n  port out WindowMoveAction currentMovementInfo;\n\n  // Instantiating sub components:\n  WindowController controller;\n  WindowPositionSensor winPositionSensor;\n  FingerProtectionSensor fingerSensor;\n  WindowMotor motor;\n\n  // Connecting an incoming port of the enclosing component to a sub component\n  windowButtonCommand -&gt; controller.command;\n\n  // Connecting sub components among each other\n  winPositionSensor.winPosition -&gt; controller.position;\n  fingerSensor.order -&gt; controller.fingerProtectionOrder;\n\n  // 1. Connecting one source port with multiple target ports;\n  // 2. Connecting a sub component port to an outgoing port of the enclosing component\n  controller.winMoveAction -&gt; motor.moveOrder,\n                              currentMovementInfo;\n}\n</code></pre> Components can be defined to be a composition of other components. These decomposed components are hierarchically structured into further subcomponents and thus have their behavior derived from the sub component's composition.</p>"},{"location":"component/Decomposition/#subcomponents","title":"Subcomponents","text":"<pre><code>component WindowSystem {\n\n  // Instantiating subcomponents:\n  WindowController controller;\n  WindowPositionSensor winPositionSensor;\n  FingerProtectionSensor fingerSensor;\n  WindowMotor motor;\n\n  // ...\n}\n</code></pre> <p>Sub components are added to a component by instantiating them within the body  of a component type definition. They are defined by first referencing the name of the component type to  instantiate, followed by a name under which one can refer to the newly  created sub component instance: <code>&lt;component-type&gt; &lt;name&gt; ;</code>. It is also possible to instantiate multiple component instances of the  same type by declaring their names in a comma-separated list after the  component type, e.g.: <code>FooComp foo1, foo2, foo3;</code></p>"},{"location":"component/Decomposition/#instantiation-of-generics","title":"Instantiation of generics","text":"<pre><code>FooComp&lt;Student, EMail&gt; foo1, foo2, foo3;\n</code></pre>"},{"location":"component/Decomposition/#instantiation-of-configurable-components","title":"Instantiation of configurable components","text":"<pre><code>FooComp foo1(0.314, true), foo2(4.2, false);\n</code></pre>"},{"location":"component/Decomposition/#connectors","title":"Connectors","text":"<p><pre><code>component WindowSystem {\n  port in WindowButtonMoveEvent windowCommand;\n  port out WindowMoveAction currentMovementInfo;\n\n  // ...\n\n  windowButtonCommand -&gt; controller.command;\n  winPositionSensor.winPosition -&gt; controller.position;\n  fingerSensor.order -&gt; controller.fingerProtectionOrder;\n  controller.winMoveAction -&gt; motor.moveOrder,\n                              currentMovementInfo;\n}\n</code></pre> Connectors connect the interfaces of components to realize component communication. They have the syntax <code>&lt;source-port&gt; -&gt; &lt;target-port&gt; ;</code> and obey following behavior: * They are directed: information can only flow through them in a predefined direction    (implicitly set by which connected port is a source and which is a target).   If a response is needed from a connected sub component, this has to be modeled as a    feedback via another communication channel * Source ports may be   * Incoming ports of the enclosing component   * Outgoing ports of a sub component * Target ports may be   * Outgoing ports of the enclosing component   * Incoming ports of a sub component * A target port may only be part of one connector. On the other hand, source  ports may participate in multiple connectors. As such, the targets of a source port can be declared within a single connector  declaration (<code>source -&gt; target1, target2, ..., targetN;</code>) or be split over multiple  multiple connector declarations:   <pre><code>source -&gt; target1;\nsource -&gt; target2;\n</code></pre> * The types of the ports participating in the connection must match.   Alternatively, the target port may have a supertype of the source port's type. * If the port ot the enclosing component type participates in the connection,  one references it just by its name. * If the port of a sub component participates in the connection, one references  it with the instance name of the connected sub component that is followed by the  name of the component's port. They are separated by a point: <code>instanceName.portName</code></p>"},{"location":"component/Generics/","title":"Generics","text":"<p><pre><code>/* Merges streams by selecting the element of one of them at a time */\ncomponent Selector&lt;T&gt;(SelectionRule&lt;T, T, Boolean&gt; rule) {\n  port in T elementA,\n       in T elementB,\n       out T selectedElement;\n\n      // ...\n}\n</code></pre> To facilitate reuse, generic components can be parametrized with type parameters. The type parameters can then be used as types for ports, parameters, or other entities in the behavior definition of a component. For defining multiple type parameters, one separates them using commas: <pre><code>component Foo&lt;K, V&gt; { /*...*/}\n</code></pre></p>"},{"location":"component/Generics/#instantiation","title":"Instantiation","text":"<p>When instantiating a generic component, one has bind its type parameters with given types: <pre><code>component HumanMachineInterface {\n  port out WindowButtonMoveEvent buttonBackLeftEvent;\n\n  // ...\n\n  Selector&lt;WindowButtonMoveEvent&gt; signalSelector(/*...*/);\n  signalSelector.selectedElement -&gt; buttonBackLeftEvent;  \n\n  // ...\n}\n</code></pre> Type parameters can also be bound with newly defined type parameters: <pre><code>component Oracle&lt;T&gt; {\n  port out T prediction;\n\n  Database&lt;T&gt; database;  // Used for predicting values\n  // Other sub components ...\n}\n</code></pre></p>"},{"location":"component/Generics/#extension","title":"Extension","text":"<p>When extending from a generic component, all its type parameters must be bound. Using newly defined type parameters for this is also allowed. <pre><code>component Selector&lt;T&gt;(/*...*/) extends StreamMerger&lt;T&gt; {\n  // ...\n}\n</code></pre></p>"},{"location":"component/Generics/#upper-bounds","title":"Upper bounds","text":"<p><pre><code>component AgeFilter&lt;T extends Person&gt;(int minAge) {\n  port in T unfiltered;\n  port out T filtered;\n\n  compute {\n    // Using information of the upper bound to access the age of the incoming element. \n    if (unfiltered.age &gt;= minAge) {\n      filtered = unfiltered;\n    }\n  }\n}\n</code></pre> One can limit the allowed types for binding type parameters by using upper bounds. As the upper bound introduces additional information about the type that the type parameter represents, one can access methods and fields of that type's elements within the behavior of the component. One can also define multiple upper bounds for the same type parameter by separating the upper bounds with <code>&amp;</code>s: <pre><code>component Foo&lt;K extends Worker &amp; Student, V&gt; { /*...*/ }\n</code></pre></p>"},{"location":"component/Interfaces/","title":"Interfaces","text":"<p><pre><code>component MyComp {\n  port &lt;&lt;sync&gt;&gt; in int inPort1,\n       &lt;&lt;timed&gt;&gt; in int inPort2,\n                 out int outPort1,  // No timing specified\n       &lt;&lt;untimed&gt;&gt; out int outPort2;\n\n  port out boolean outPortInSeparateDeclaration;\n}\n</code></pre> Ports are declared within the bodies of the components to which they belong. It is possible to define multiple ports within one statement. One can also split the declaration over multiple statements. This allows the textual grouping of conceptually related ports.</p> <p>The definition of a port contains the following concepts: * The port's direction: Either it is incoming or outgoing.    Through incoming ports, a component receives data from its environment.    Through outgoing ports, a component sends data to its environment. * The port's' type.   Only data of that can flow through the port. See [Type system] for more information about types. *  The port's name that is later used to refer to the port and the information flowing through it.</p>"},{"location":"component/Interfaces/#complete-syntax","title":"Complete syntax","text":"<pre><code>port (&lt;port-timing&gt;) &lt;direction&gt; &lt;type&gt; &lt;name&gt; ;\n</code></pre>"},{"location":"component/Parameter/","title":"Parameters","text":"<pre><code>component LinearScalar(double factor, double offset = 0.0) {\n  port in double baseValue,\n       out double scaledValue;\n\n  compute {\n    scaledValue = factor * baseValue + offset;\n  }\n}\n</code></pre> <p>Components can carry configuration parameters. Values are assigned to them at instantiation and can be used to influence component behavior by reading their values. When defining a component type, the definition of configuration parameters, wrapped in parenthesis, directly follow the name of the component. Multiple parameters are separated by commas. One can also define default values for parameters that then do not need to be bound during instantiation. Note however, that once a parameter has a default value, all following parameters must have default values, too.</p>"},{"location":"component/Parameter/#instantiation-of-components-with-configuration-parameters","title":"Instantiation of components with configuration parameters","text":"<pre><code>component MeasureNet {\n  LinearScalar scaleAndAdd(3.0, 10);\n  LinearScalar justScale(2.0);  // justScale's offset is implicitly assigned 0.0, the default value\n\n  // The rest of the component is omitted here.\n}\n</code></pre>"},{"location":"typesystem/ClassDiagrams/","title":"Class Diagrams","text":"<p><pre><code>package corp;\nimport java.util.Date;\n\nclassdiagram MyCompany {\n\n  enum CorpKind { SOLE_PROPRIETOR, S_CORP, C_CORP, B_CORP, CLOSE_CORP, NON_PROFIT; }\n  abstract class Entity;\n  package people {\n    class Person extends Entity {\n      Date birthday;\n      List&lt;String&gt; nickNames;\n      -&gt; Address [*] {ordered};\n    }\n    class Address {\n      String city;\n      String street;\n      int number;\n    }\n  }\n  class Company extends Entity {\n    CorpKind kind;\n  }\n  class Employee extends people.Person {\n    int salary;\n  }\n  class Share {\n    int value;\n  }\n  association [1..*] Company (employer) &lt;-&gt; Employee [*];\n  composition [1] Company &lt;- Share [*];\n  association shareholding [1] Entity (shareholder) -- (owns) Share [*];\n}\n</code></pre> UML class diagrams are a handy way to define object oriented types. MontiArc has an integration for class diagrams written with [cd4code][cd4analysis] (a language extension of cd4analysis). cd4code features the definition of * Enums * Interfaces * Classes * Abstract classes * Field members * Method members * Associations between classes, also featuring cardinalities * Package structures</p>"},{"location":"typesystem/ClassDiagrams/#comprehensive-information","title":"Comprehensive information","text":"<p>You can find comprehensive information on how to define types with cd4code [here][cd4analysis]. Moreover there are [several examples][examples] of cd4code models.</p>"},{"location":"typesystem/ClassDiagrams/#special-behavior-of-class-diagram-usage-in-montiarc","title":"Special behavior of class diagram usage in MontiArc","text":"<p>There are some things that you should note when working with object oriented types in MontiArc:</p>"},{"location":"typesystem/ClassDiagrams/#packages","title":"Packages","text":"<p>Class diagrams themselves are defined within a package structure. However, they themselves also span a new package. E.g., take the following class diagram model: <pre><code>package com.example;\n\nclassdiagram fingerprotection {\n  public enum FingerProtectionOrder {\n    PROTECT, PROTECTION_OFF;\n  }\n}\n</code></pre> The <code>FingerProtectionOrder</code> type will be located in the <code>com.example.fingerprotection</code> package. Note that the class diagram name becomes a part of the package name. To use the type in MontiArc, one would be importing it at the beginning of the MontiArc model: <pre><code>package com.example.window;\n\nimport com.example.fingerprotection.FingerProtectionOrder;\n\ncomponent WindowController { /*...*/ }\n</code></pre></p>"},{"location":"typesystem/ClassDiagrams/#calling-constructors","title":"Calling constructors","text":"<p><pre><code>compute {\n  personOutPort = Person.Person(\"Steven\");\n}\n</code></pre> When calling constructors of object oriented types in MontiArc, one calls the constructor as if it was a method of the defining type: <pre><code>TypeName.methodName(/*arguments*/)\n</code></pre> As the constructor method name is the same as the type name, this syntax becomes <pre><code>TypeName.TypeName(/*arguments*/)\n</code></pre></p>"},{"location":"typesystem/JavaIntegration/","title":"Java Integration","text":"<p>When enabling the <code>class2mc</code> option, then the Java standard library is available in all MontiArc models.</p>"},{"location":"typesystem/JavaIntegration/#special-behavior-of-java-type-usage-in-montiarc","title":"Special behavior of Java type usage in MontiArc","text":"<p>Note that calling constructors of object oriented types in MontiArc obeys a special syntax: <pre><code>compute {\n  personOutPort = Person.Person(\"Steven\");\n}\n</code></pre> When calling constructors, one calls the constructor as if it was a method of the defining type: <pre><code>TypeName.methodName(/*arguments*/)\n</code></pre> As the constructor method name is the same as the type name, this syntax becomes <pre><code>TypeName.TypeName(/*arguments*/)\n</code></pre></p>"},{"location":"typesystem/Primitives/","title":"Primitives","text":"<pre><code>component Dummy {\n  int myIntField = 0;\n  long myLongField = 0;\n\n  float myFloatField = 0.0f;\n  double myDoubleField = 0.0;\n\n  boolean myBoolField = false;\n  char myCharField = 'a';\n}\n</code></pre> <p>MontiArc provides the following primitive data types:</p>"},{"location":"typesystem/Primitives/#integer-numbers","title":"Integer numbers","text":"<ul> <li><code>int</code> with values between <code>-2\u00b3\u00b9</code> and <code>2\u00b3\u00b9 - 1</code></li> <li><code>long</code> with values between <code>-2\u2076\u00b3</code> and <code>2\u2076\u00b3 - 1</code></li> </ul> <p>Normally, integer literals are of the type <code>int</code>. However, it is also possible to create literals that are explicitly of the type <code>long</code> by adding an <code>l</code> or <code>L</code> as a suffix: <code>42l</code> or <code>42L</code>. (<code>L</code> is the recommended suffix, as <code>l</code> is similar to <code>1</code>). Values of type <code>int</code> can be assigned to entities of the <code>long</code>, <code>double</code>, <code>float</code>, and <code>char</code> type.</p>"},{"location":"typesystem/Primitives/#floating-point-numbers","title":"Floating point numbers","text":"<ul> <li><code>float</code> is a single-precision 32-bit IEEE 754 floating point</li> <li><code>double</code> is a double-precision 64-bit IEEE 754 floating point</li> </ul> <p>The behavior of floating point numbers (e.g. rounding after math operations) follows the behavior of [Java's floating point] numbers. Normally, floating point literals are of the type <code>double</code>. However, it is also possible to create literals of the type <code>float</code> by adding an <code>f</code> or <code>F</code> as a suffix: <code>2.0f</code> or <code>2.0F</code>.  Values of the type <code>float</code> can be assigned to entities of the <code>double</code> type.</p>"},{"location":"typesystem/Primitives/#boolean-values","title":"Boolean values","text":"<p><code>boolean</code> data can have two different values: <code>true</code> and <code>false</code></p>"},{"location":"typesystem/Primitives/#character-values","title":"Character values","text":"<p><code>char</code> is a 16-bit Unicode character. It is possible to define a character value by its unicode code point. To this end, the hexadecimal unicode code is following the unicode escape <code>\\u</code>: <code>char foo = '\\u0F23'</code>. Moreover, MontiArc features the [same escape codes as Java][java escape codes] for commonly used control characters such as <code>\\n</code> for new line. Character values can be assigned to entities of the <code>int</code>, <code>long</code>, <code>double</code>, and <code>float</code> type.</p>"},{"location":"typesystem/Primitives/#void","title":"Void","text":"<p>While the <code>void</code> type is not usable as type of values, it is recognized as the return type of methods that do not return anything: <pre><code>automaton {\n  // ...\n  A -&gt; B / { executeVoidMethod(); };\n}\n</code></pre></p>"},{"location":"usage/CD2PojoCLTool/","title":"CD2Java CL Tool","text":"<p>The CD2PojoTool offers capabilities for processing class diagram models that later should be used within MontiArc models. It provides multiple options that can be used as follows: <pre><code>java -jar CD2PojoTool.jar [-h] -i &lt;dirlist&gt; [-path &lt;p&gt;] [-pp [&lt;file&gt;]] [-s [&lt;file&gt;]] [-o &lt;dir&gt;]\n</code></pre></p> <p>where the arguments are:</p> Option Explanation <code>-i, --input &lt;dirlist&gt;</code> Sets the directories in which the class diagram models are. <code>-o, --output &lt;dir&gt;</code> Sets the target path for the generated files (optional). <code>-hwc, --handwrittencode &lt;dir&gt;</code> Sets the artifact path for handwritten code customizations(optional). <code>-path &lt;dirlist&gt;</code> Sets the artifact path for imported symbols (of other class diagram models) (optional). <code>-pp, --prettyprint &lt;dir&gt;</code> Prints the AST of the class diagram models to stdout or the specified directory (optional). <code>-s, --symboltable &lt;dir&gt;</code> Serializes and prints the symbol table to stdout or the specified output directory (optional). This creates <code>.cdcsym</code> files. <code>-c2mc, --class2mc&gt;</code> Makes Java types from the class path or the symboltable directory available as types in class diagram models. These can be either <code>.class</code> files, or bundled within <code>.jar</code> archives. <code>-h, --help</code> Prints the help dialog. <code>-v, --version</code> Prints version information. <p>Exemplary usage:</p> <p>With Linux/MacOS: <pre><code>java -jar CD2PojoTool.jar \\\n  --input src/cd2pojo \\\n  -hwc src/java \\\n  --output target/cd2pojo/java \\\n  --symboltable target/cd2pojo/symbols \\\n  -c2mc\n</code></pre></p> <p>With Windows: <pre><code>java -jar CD2PojoTool.jar ^\n  --input src\\cd2pojo ^\n  -hwc src\\java ^\n  --output target\\cd2pojo\\java ^\n  --symboltable target\\cd2pojo\\symbols ^\n  -c2mc\n</code></pre></p>"},{"location":"usage/CD2PojoGradlePlugin/","title":"CD2Java Gradle Plugin","text":"<p>This plugin generates Java code from cd2pojo models. Moreover, it distributes cd2pojo models as jars with <code>.cdsym</code> files.</p>"},{"location":"usage/CD2PojoGradlePlugin/#apply-it","title":"Apply it:","text":"<p>Within gradle's settings script, you need to declare:</p> <p>With Groovy: <pre><code>// The plugin is in the Maven repo of the chair of Software Engineering at RWTH Aachen.\n// Therefore we have to make it available to our build process.\npluginManagement {\n  repositories {\n    maven {\n      url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n    }\n  }\n}\n</code></pre></p> <p>With Groovy: <pre><code>// The plugin is in the Maven repo of the chair of Software Engineering at RWTH Aachen.\n// Therefore we have to make it available to our build process.\npluginManagement {\n  repositories {\n    maven {\n      url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n    }\n  }\n}\n</code></pre></p> <p>Then, within the build script, you need to declare:</p> <p>With Kotlin: <pre><code>plugins {\n  id(\"cd2pojo\") version \"VERSION_YOU_WANT_TO_USE\"\n}\n\n// The generator is in the Maven repo of the chair of Software Engineering at RWTH Aachen\nrepositories {\n  maven {\n    url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n  }\n}\n</code></pre></p> <p>With Groovy: <pre><code>plugins {\n  id \"cd2pojo\" version \"VERSION_YOU_WANT_TO_USE\"\n}\n\n// The generator is in the Maven repo of the chair of Software Engineering at RWTH Aachen\nrepositories {\n  maven {\n    url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n  }\n}\n</code></pre></p>"},{"location":"usage/CD2PojoGradlePlugin/#configure-it","title":"Configure it:","text":"<p>The plugin adds a CD2PojoCompile task for every source set that exists. The name of that task is <code>compileSRC_SET_NAMECd2pojo</code>, omitting the name of the source set for the main source set.</p> <p>Note that Java source files that the cd2pojo generator produces are automatically added to the Java source of the same source set. Therefor, the generated source code will automatically be compiled by <code>compileJava</code> (or <code>compileTestJava</code>, etc.).</p> <p>With Kotlin: <pre><code>// Kotlin:\nsourceSets {\n  main {\n    cd2pojo {\n      srcDir(\"where/your/cd2pojo/models/are\") // default value: $projectDir/src/SOURCE_SET_NAME/cd2pojo\n      destinationDirectory.fileValue(file(\"where/to/generate/the/code/to\"))  // default value: $buildDir/cd2pojo/SOURCE_SET_NAME\n    }\n  }\n}\n\n// Declare dependencies on published models\ndependencies {\n  cd2pojo(\"some.model.publisher:factory-types:1.2.0\")\n  testCd2pojo(\"some.testModel.publisher:factory-testers:1.2.0\")\n}\n\ntask.compileCd2pojo {  // compile task for other sourceSets: \"compile{SRC_SET_NAME}Cd2pjo\"\n  symbolImportDir.from(\"${projectDir}/src/SRC_SET_NAME/more_symbols\")\n  useClass2Mc.set(true)  // Default value is false\n}\n\ncd2pojo {\n  // Only use the following option if you build the MontiArc project itself!\n  // Else ignore it (You can just omit the option).\n  internalMontiArcTesting.set(true)\n}\n</code></pre></p> <p>With Groovy: <pre><code>sourceSets {\n  main {\n    cd2pojo {\n      srcDir \"where/your/cd2pojo/models/are\"  // default value: $projectDir/src/SOURCE_SET_NAME/cd2pojo\n      destinationDirectory.fileValue(file(\"where/to/generate/the/code/to\"))  // default value: $buildDir/cd2pojo/SOURCE_SET_NAME\n    }\n  }\n}\n\n// Declare dependencies on published models\ndependencies {\n    cd2pojo \"some.model.publisher:factory-types:1.2.0\"\n    testCd2pojo \"some.testModel.publisher:factory-testers:1.2.0\"\n}\n\ntask.compileCd2pojo {  // compile task for other sourceSets: \"compile{SRC_SET_NAME}Cd2pojo\"\n  symbolImportDir.from(\"${projectDir}/src/SRC_SET_NAME/more_symbols\")\n  useClass2Mc.set(true)  // Default value is false\n}\n\ncd2pojo {\n  // Only use the following option if you build the MontiArc project itself!\n  // Else ignore it (You can just omit the option).\n  internalMontiArcTesting.set(true)\n}\n</code></pre></p> <p>Note that the generated java code will be generated to <code>$destinationDirectory/java</code> and created <code>.cdsym</code> files are placed in <code>$destinationDirectory/symbols</code> (<code>destinationDirectory</code> being defined in the <code>cd2pojo</code> entry of the source set).</p>"},{"location":"usage/CD2PojoGradlePlugin/#configuration-options-in-detail","title":"Configuration options in detail:","text":"<p>Each CD2PojoComile task has the following configuration options that can be set. Some configuration options only have default values, if the task is created for a source set.</p> Option Default value Description modelPath <code>$projectDir/src/SOURCE_SET_NAME/cd2pojo</code> Where to find the class diagram models for which Java code should be generated. You can specify multiple locations with multiple <code>modelPath.from(...)</code> statements. hwcPath All java code from the same source set (main, or test, etc.) Where to find the handwritten code extensions for the generated class diagram code. symbolImportDir The <code>cd2pojoSymbolDependencies</code> configuration If you want to use <code>.sym</code> files, then you can use this configuration parameter to inform the generator where to find them. You can specify multiple locations with multiple <code>symbolImportDir.from(...)</code> statements. useClass2Mc <code>false</code> If you want to use java types (or other JVM types) in your class diagram models, then you set this configuration parameter to <code>true</code>. By this, all JVM types that are on the class path of the generator (which is the configuration <code>cd2pojoGenerator</code>) will be accessible from class diagram models. Note: this will be changed in the future. outputDir <code>$buildDir/cd2pojo/SOURCE_SET_NAME</code> Where the generated files should be placed. Generated Java code ist placed in the <code>java</code> subfolder, exported symbol files are put in the <code>symbols</code> subfolder. <p>Moreover, there are the following options configurable in the <code>cd2pojo</code> block:</p> Option Default value Description internalMontiArcTesting <code>false</code> If you are not a MontiArc developer, just ignore it (and omit the option, as its default value is <code>false</code>). Otherwise: if you want to apply the plugin from within the MontiArc project, e.g., to test the generator in an integration test, then set this to <code>true</code>. By this, the freshly compiled (unpublished) generator will be used instead of the one from the maven repository."},{"location":"usage/CD2PojoGradlePlugin/#added-build-elements","title":"Added build elements","text":"<ul> <li>The Plugin adds the dependency configuration cd2pojoGenerator on which it places the dependency on the generator    that is used to generate .java code from the .cd files. If you use <code>class2mc</code>, then you can place the java classes   that you want to use in your models on this configuration.</li> <li>For every SourceSet, the plugin</li> <li>Adds a CD2PojoCompile task that performs the generation step from .cd models     to .java code. The task name is <code>compileCd2pojo</code> for main and <code>compileSourceSetNameCd2pojo</code> for others</li> <li>Adds a jar task packaging the .cdsym models of the main source set, adding it to the default publication.</li> <li>Adds three configurations:<ul> <li><code>cd2pojo</code> for the main source set and <code>sourceSetNameCd2Pojo</code> for others:\\   Used to declare dependencies on other cd2pojo models. This configuration is not resolvable or consumable and only   serves the purpose to declare dependencies. The models of the dependencies will automatically be added to the   symbolImportDir of the <code>compileCd2pojo</code> task and their java implementations will automatically be added to the   <code>implementation</code> configuration for compilation and runtime. To this end, <code>implementation</code> extends the <code>cd2pojo</code>   configuration, as do:</li> <li><code>cd2pojoSymbolDependencies</code> for the main source set and <code>sourceSetNameCd2pojoSymbolDependencies</code> for others:\\   Only contains the cd models of the dependencies (represented by .cdsym files). Do not use   this configuration to declare the dependencies (use <code>cd2pojo</code> for this purpose instead), but use this   configuration, when you want to access the cd2pojo models of the dependencies. (This configuration is derived   from the <code>cd2pojo</code> configuration, only considering the cd2pojo models.)</li> <li><code>cd2pojoSymbolElements</code> for the main source set and <code>sourceSetNameCd2pojoSymbolElements</code> for others:\\   Contains the jar of the cd2pojo models (represented by .cdsym files) that is added to the default publication   set. By default, this configuration is only added for the main source set.</li> </ul> </li> <li>Models declared in the main source set are also available in the test source sets.</li> </ul>"},{"location":"usage/CD2PojoGradlePlugin/#fixing-problems","title":"Fixing problems:","text":"<ul> <li>The generator only generates classes with a TOP postfix\\   When you use the default value of the hwcPath, the outputDir may erroneously be in the hwcPath, because   filtering the outputDir went wrong. In this case the generator thinks that the previously generated files are   handwritten extensions. To fix this, you should set the hwcPath manually. This will overwrite the default value,   including the entry with the outputDir.</li> <li>There is no main or test source set\\   These source sets only exist if the java plugin is applied. If only the java-base plugin is applied, then there   are no main or tests source sets.</li> <li>If your dependencies use class2mc, then you have to activate it for your own project, too.</li> <li>If you activate class2mc for your main source set, you also have to activate it for your test source set.</li> </ul>"},{"location":"usage/GettingStarted/","title":"Getting Started","text":"<p>This page aims to help you to compile your first MontiArc models. MontiArc projects can be developed with the Gradle build tool. On the other hand, there is also a CLI tool that you can use to process MontiArc models.</p>"},{"location":"usage/GettingStarted/#using-gradle","title":"Using Gradle","text":"<p>Using Gradle to process MontiArc models brings some advantages, such as: * Easier configuration of model processing * Dependency management that allows you to publish models and to depend on other MontiArc libraries * Automatic compilation of MontiArc's generated code (if the java plugin is also applied)</p>"},{"location":"usage/GettingStarted/#prequisites","title":"Prequisites","text":"<ul> <li>Gradle 7.5 is required to execute the MontiArc build process.</li> <li>Java 11 is the version of the code produced by the MontiArc generator.</li> <li>(MontiArc 7.5.0 mistakenly requires Java 17 when using the Gradle plugin.   Use a higher MontiArc version if you want to use Java 11.)</li> </ul>"},{"location":"usage/GettingStarted/#montiarc-project-structure","title":"MontiArc project structure","text":"<p>When using Gradle to build MontiArc applications, the default project structure looks like the following: <pre><code>project-root\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 main\n\u2502   \u2502   \u251c\u2500\u2500 java        // Present if you also apply the java plugin\n\u2502   \u2502   \u251c\u2500\u2500 montiarc\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 com\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 example\n\u2502   \u2502   \u2502           \u251c\u2500\u2500 ComponentA.arc\n\u2502   \u2502   \u2502           \u2514\u2500\u2500 ComponentB.arc\n\u2502   \u2502   \u2514\u2500\u2500 resources   // If you also apply the java plugin\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 test\n\u2502       \u251c\u2500\u2500 java        // If you also apply the java plugin\n\u2502       \u251c\u2500\u2500 montiarc\n\u2502       \u2514\u2500\u2500 resources   // If you also apply the java plugin\n\u2502\n\u251c\u2500\u2500 build\n\u2502   \u251c\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 montiarc\n\u2502       \u251c\u2500\u2500 main\n\u2502       \u2502   \u251c\u2500\u2500 java     // Generated code remains here\n\u2502       \u2502   \u2514\u2500\u2500 symbols  // Here, .symarc files are placed.\n\u2502       \u2502                // These are variants of your models that are meant for distribution\n\u2502       \u2514\u2500\u2500 test\n\u2502           \u251c\u2500\u2500 java\n\u2502           \u2514\u2500\u2500 symbols\n\u2502\n\u251c\u2500\u2500 build.gradle\n\u2514\u2500\u2500 settings.gradle\n</code></pre> For every source set (e.g. <code>main</code> or <code>test</code> if you apply the java plugin) your MontiArc models can be placed under the path <code>src/SOURCE_SET_NAME/montiarc</code>, e.g. <code>src/main/montiarc</code>. Similar to Java, MontiArc models are organized in package structures that are also reflected by the directory structure in which they are saved. E.g. if a model is in the package <code>com.example</code>, then its file should be under the path <code>montiarc/com/example</code>. You can also change the location in which models are found.</p>"},{"location":"usage/GettingStarted/#project-setup","title":"Project setup","text":"<p>To enable the usage of the MontiArc plugin, we have to add the repository in which it lays to the settings file of gradle:</p> <p>{{&lt; tabs \"gradle-settings-file\" &gt;}} {{&lt; tab \"Kotlin\" &gt;}}  <pre><code>// If your settings file is settings.gradle.kts (namely, it uses kotlin syntax)\n\n// The generator is in the Maven repo of the chair of Software Engineering at RWTH Aachen.\n// Therefore we have to make it available to our build process.\npluginManagement {\n  repositories {\n    maven {\n      url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n    }\n  }\n}\n</code></pre> {{&lt; /tab &gt;}} {{&lt; tab \"Groovy\" &gt;}}  <pre><code>// If your settings file is settings.gradle (namely, it uses groovy syntax)\n\n// The generator is in the Maven repo of the chair of Software Engineering at RWTH Aachen.\n// Therefore we have to make it available to our build process.\npluginManagement {\n  repositories {\n    maven {\n      url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n    }\n  }\n}\n</code></pre> {{&lt; /tab &gt;}} {{&lt; /tabs &gt;}}</p> <p>We can then apply the plugin by adding the following to Gradle's Build file: {{&lt; tabs \"gradle-build-file\" &gt;}} {{&lt; tab \"Kotlin\" &gt;}}  <pre><code>// Use this code if your build file is build.gradle.kts (namely, it uses kotlin syntax)\nplugins {\n  id(\"java\")  // Optional, but recommended for this tutorial\n  id(\"montiarc\") version \"VERSION_YOU_WANT_TO_USE\"\n}\n\n// Required RTE classes are in the Maven repo of the chair of Software Engineering at RWTH Aachen.\n// Therefore we have to add this repo to our build.\nrepositories {\n  maven {\n    url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n  }\n}\n</code></pre> {{&lt; /tab &gt;}} {{&lt; tab \"Groovy\" &gt;}}  <pre><code>// Use this code if your build file is build.gradle (namely, it uses groovy syntax)\nplugins {\n  id \"java\"  // Optional, but recommended for this tutorial\n  id \"montiarc\" version \"VERSION_YOU_WANT_TO_USE\"\n}\n\n// Required RTE classes are in the Maven repo of the chair of Software Engineering at RWTH Aachen.\n// Therefore we have to add this repo to our build.\nrepositories {\n  maven {\n    url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n  }\n}\n</code></pre> {{&lt; /tab &gt;}} {{&lt; /tabs &gt;}}</p> <p>You can now place your models in the <code>src/main/montiarc</code> folder of your project.</p>"},{"location":"usage/GettingStarted/#executing-the-generation-process","title":"Executing the generation process","text":"<p>Gradle can be run as a standalone tool from the command line, or from IDEs by using plugins: * IntelliJ IDEA comes with the Gradle and Gradle Extension plugins shipped by default * Eclipse gains Gradle support using the Gradle Buildship Plugin * VS Code gains Gradle support using the Gradle for Java Extension</p> <p><code>compileMontiarc</code> is the Gradle task that executes the MontiArc generation process. Executing the <code>build</code> task will also trigger the generation. It will additionally compile the generated Java code if the java plugin is also applied.</p> <p>Try creating a simple MontiArc model at the location of <code>src/main/montiarc/com/example/MyComp.arc</code>: <pre><code>package com.example;\n\ncomponent MyComp { }\n</code></pre></p> <p>Now execute the <code>compileMontiarc</code> task with Gradle. Check that, as a result, the java class <code>MyComp</code> should be generated to <code>build/montiarc/main/java/com/example/MyComp.java</code>.</p> <p>If you also want that the <code>build</code> task compiles the generated code, then also apply the java plugin in your build script (if you have not done this yet): {{&lt; tabs \"gradle-apply-java\" &gt;}} {{&lt; tab \"Kotlin\" &gt;}}  <pre><code>// If your build file is build.gradle.kts (namely, it uses kotlin syntax)\nplugins {\n  id(\"java\")\n  id(\"montiarc\") version \"VERSION_YOU_WANT_TO_USE\"\n}\n</code></pre> {{&lt; /tab &gt;}} {{&lt; tab \"Groovy\" &gt;}}  <pre><code>// If your build file is build.gradle (namely, it uses groovy syntax)\nplugins {\n  id \"java\"\n  id \"montiarc\" version \"VERSION_YOU_WANT_TO_USE\"\n}\n</code></pre> {{&lt; /tab &gt;}} {{&lt; /tabs &gt;}}</p>"},{"location":"usage/GettingStarted/#adding-class-diagrams-to-your-project","title":"Adding class diagrams to your project","text":"<p>You can declare class diagram models to be used by MontiArc by applying the cd2pojo plugin. In order to do this, add the cd2pojo plugin to the <code>plugins</code> block within the build script:</p> <p>{{&lt; tabs \"gradle-apply-cd2pojo\" &gt;}} {{&lt; tab \"Kotlin\" &gt;}}  <pre><code>// If your build file is build.gradle.kts (namely, it uses kotlin syntax)\nplugins {\n  id(\"java\")\n  id(\"montiarc\") version \"VERSION_YOU_WANT_TO_USE\"\n  id(\"cd2pojo\") version \"VERSION_YOU_WANT_TO_USE\"\n}\n</code></pre> {{&lt; /tab &gt;}} {{&lt; tab \"Groovy\" &gt;}}  <pre><code>// If your build file is build.gradle (namely, it uses groovy syntax)\nplugins {\n  id \"java\"\n  id \"montiarc\" version \"VERSION_YOU_WANT_TO_USE\"\n  id \"cd2pojo\" version \"VERSION_YOU_WANT_TO_USE\"\n}\n</code></pre> {{&lt; /tab &gt;}} {{&lt; /tabs &gt;}}</p> <p>The project structure of projects with class diagrams is similar to projects with MontiArc (but can also be customized): <pre><code>project-root\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 main\n\u2502   \u2502   \u251c\u2500\u2500 cd2pojo\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 ...     // Put your class diagram models here\n\u2502   \u2502   \u251c\u2500\u2500 java        // Present if you also apply the java plugin\n\u2502   \u2502   \u251c\u2500\u2500 montiarc    // If you also apply the montiarc plugin\n\u2502   \u2502   \u2514\u2500\u2500 resources   // If you also apply the java plugin\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 test\n\u2502       \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 build\n\u2502   \u251c\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 cd2pojo\n\u2502       \u251c\u2500\u2500 main\n\u2502       \u2502   \u251c\u2500\u2500 java\n\u2502       \u2502   \u2514\u2500\u2500 symbols\n\u2502       \u2514\u2500\u2500 test\n\u2502           \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 build.gradle\n\u2514\u2500\u2500 settings.gradle\n</code></pre></p> <p>Try creating a simple class diagram model at the location of <code>src/main/cd2pojo/com/example/MyTypes.cd</code>: <pre><code>package com.example;\n\nclassdiagram MyTypes {\n  public enum Status {\n    ACTIVE,\n    STAND_BY;\n  }\n}\n</code></pre></p> <p>Now use the enum type in your MontiArc model <code>MyComp</code>: <pre><code>package com.example;\n\nimport com.example.MyTypes.Status;\n\ncomponent MyComp(Status initialStatus) { }\n</code></pre></p> <p>Execute the <code>compileMontiarc</code> task with Gradle. Check that no error occurs. Moreover, verify that the java class <code>Status</code> has been generated to <code>build/cd2pojo/main/java/com/example/MyTypes/Status.java</code>. Note: If an error occurs, try running Gradle's <code>clean</code> task before. </p>"},{"location":"usage/GettingStarted/#using-java-types","title":"Using java types","text":"<p>You can use JDK classes from MontiArc models by setting the <code>useClass2mc</code> option of the generation task in Gradle's build script: <pre><code>// The syntax is the same for Kotlin and Groovy build scripts\ntask.compileMontiarc {\n  useClass2Mc.set(true)\n}\n</code></pre></p> <p>Now use <code>String</code> in your MontiArc model <code>MyComp</code>: <pre><code>package com.example;\n\n// Types from java.lang are automatically imported.\n// For types from other packages, import them\n// E.g.: \n// import com.example.MyJavaType;\n\ncomponent MyComp(String prefix) {}\n</code></pre></p> <p>Execute the <code>compileMontiarc</code> task with Gradle. Check that no error occurs.</p> <p>Java types can be used similarly from within class diagram models. To this end, the <code>useClass2Mc</code> option has to be set for the <code>compileCd2pojo</code> task that under the hood processes the class diagram models: <pre><code>// Add the following to your build file:\ntask.compileCd2pojo {\n  useClass2Mc.set(true)\n}\n</code></pre></p> <p>Note that, if you use java types from class diagrams, than you also have to set the <code>useClass2Mc</code> option for your MontiArc models. Else, you will encounter errors.</p>"},{"location":"usage/GettingStarted/#further-references","title":"Further references","text":"<p>Applying the MontiArc Gradle plugin provides further benefits, like publishing your MontiArc models and depending on the models of other people. It also enables fine configuration options. You can find comprehensive information about the MontiArc plugin under [MontiArc Gradle Plugin] and about the cd2pojo plugin under [Cd2pojo Gradle Plugin].</p>"},{"location":"usage/GettingStarted/#using-the-command-line","title":"Using the command line","text":""},{"location":"usage/GettingStarted/#execute-the-cli-generation-process","title":"Execute the CLI generation process","text":"<p>The main command line options are: | Option                       | Explanation                                              | |------------------------------|----------------------------------------------------------| | <code>-i, --input &lt;dirlist&gt;</code> | Declare the directory in which your MontiArc models are. | | <code>-o, --output &lt;dir&gt;</code>         | Sets the target path for the generated files (optional). |</p> <p>To exemplify the usage, lets consider the following example: Having a project <code>demo</code>, create a MontiArc model in <code>demo/src/montiarc/com/example/MyComp.arc</code>: <pre><code>package com.example;\n\ncomponent MyComp { }\n</code></pre></p> <p>Now execute the CLI tool: <pre><code># Being in the 'demo' directory\njava -jar TODONAME --input src/montiarc --output build/montiarc/java\n</code></pre> Check that this generates the java class <code>MyComp</code> at <code>demo/build/montiarc/java/com/example/MyComp.java</code>.</p>"},{"location":"usage/GettingStarted/#using-class-diagrams-in-montiarc","title":"Using class diagrams in MontiArc","text":"<p>To use class diagrams, we first have to export them, as MontiArc has no processing infrastructure for <code>.cd</code> files. Therefore, we must export them to symbolic <code>.cdsym</code> files first. To this end, a generator cd2pojo is provided here, having similar requirements as the ma2java generator. Its main command line options are: | Option                       | Explanation                                              | |------------------------------|----------------------------------------------------------| | <code>-i, --input &lt;dirlist&gt;</code>      | Declare the directory in which your class diagram models are. | | <code>-c, --checkcocos</code>           | Verifies the correctness of class diagram models (optional, but recommended). | | <code>-o, --output &lt;dir&gt;</code>         | Sets the target path for the generated java files (optional). | | <code>-s, --symboltable &lt;dir&gt;</code>    | Sets the target path to which symbolic files are exported (optional). | As we can see, we can use the <code>--symboltable</code> option to export the <code>.cdsym</code> files that MontiArc can read. E.g. create a class diagram model at <code>demo/src/cd2pojo/com/example/MyTypes.cd</code>: <pre><code>package com.example;\n\nclassdiagram MyTypes {\n  public enum Status {\n    ACTIVE,\n    STAND_BY;\n  }\n}\n</code></pre></p> <p>Now execute the generator: <pre><code># Being in the 'demo' directory\njava -jar TODO --checkcocos --input src/cd2pojo --symboltable build/cd2pojo/symbols --output build/cd2pojo/java\n</code></pre> Now check that this created the symbol file <code>demo/build/cd2pojo/symbols/com/example/MyTypes/Status.cdsym</code>. We also generated a java implementation of the class diagram at <code>demo/build/cd2pojo/java/com/example/MyTypes/Status.java</code>. If you do not want to use the generated java implementations, you may omit the <code>--output</code> option.</p> <p>We can now use the class diagram in MontiArc. To this end, modify <code>MyComp</code>: <pre><code>package com.example;\n\nimport com.example.MyTypes.Status;\n\ncomponent MyComp(Status initialStatus) { }\n</code></pre></p> <p>We can now use the <code>-path</code> option of the MontiArc generator to specify directories in which symbol files lay. The symbol files are also allowed to be wrapped in jar files. Try to execute the generator: <pre><code># Being in the 'demo' directory\njava -jar TODONAME --input src/montiarc -path build/cd2pojo/symbols --output build/montiarc/java\n</code></pre> Verify that no error occurs.</p>"},{"location":"usage/GettingStarted/#using-java-types_1","title":"Using java types","text":"<p>We can use java types form MontiArc models by setting the <code>-c2mc / --class2mc</code> command line option of the MontiArc generator. This will make all java types of the generators class-path available to MontiArc models. Moreover, one can put jars with the types to be used on the <code>-path</code> command line option. JDK types are available by default.</p> <p>Let's modify <code>MyComp</code>: <pre><code>package com.example;\n\nimport java.lang.String;  // TODO: test whether String is automatically imported\n\ncomponent MyComp(String initialStatus) { }\n</code></pre></p> <p>Now execute the generator and verify that no error occurs: <pre><code># Being in the 'demo' directory\njava -jar TODONAME --input src/montiarc --class2mc --output build/montiarc/java\n</code></pre></p> <p>Note that the class diagram generator also has an <code>-c2mc / class2mc</code> option to enable the use of java types in class diagram models.</p>"},{"location":"usage/MontiArcCLTool/","title":"MontiArc CL Tool","text":"<p>The MA2JavaTool offers capabilities for processing MontiArc component  models via the command line. It provides multiple options that can be used as follows: <pre><code>java -jar MA2JavaTool.jar [-h] -i &lt;dirlist&gt; [-path &lt;p&gt;] [-pp [&lt;file&gt;]] [-s [&lt;file&gt;]] [-o &lt;dir&gt;]\n</code></pre></p> <p>where the arguments are:</p> Option Explanation <code>-i, --input &lt;dirlist&gt;</code> Sets the directories in which the MontiArc models are. <code>-o, --output &lt;dir&gt;</code> Sets the target path for the generated files (optional). <code>-hwc &lt;dir&gt;</code> Sets the artifact path for handwritten code customizations(optional). <code>-path &lt;dirlist&gt;</code> Sets the artifact path for imported symbols (of other MontiArc or class diagram models) (optional). <code>-pp, --prettyprint &lt;dir&gt;</code> Prints the AST of the component models to stdout or the specified directory (optional). <code>-s, --symboltable &lt;dir&gt;</code> Serializes and prints the symbol table to stdout or the specified output directory (optional). This creates <code>.arcsym</code> files. <code>-c2mc, --class2mc&gt;</code> Makes Java types from the class path or the symboltable directory available as types in MontiArc models. These can be either <code>.class</code> files, or bundled within <code>.jar</code> archives. <code>-h, --help</code> Prints the help dialog. <code>-v, --version</code> Prints version information. <p>Exemplary usage:</p> <p>On Linux/MacOS: <pre><code>java -jar MA2JavaTool.jar \\\n  --input src/montiarc \\\n  -hwc src/java \\\n  --output target/montiarc/java \\\n  --symboltable target/montiarc/symbols \\\n  -c2mc\n</code></pre> On Windows: <pre><code>java -jar MA2JavaTool.jar ^\n  --input src\\montiarc ^\n  -hwc src\\java ^\n  --output target\\montiarc\\java ^\n  --symboltable target\\montiarc\\symbols ^\n  -c2mc\n</code></pre></p>"},{"location":"usage/MontiArcGradlePlugin/","title":"MontiArc Gradle Plugin","text":"<p>This plugin generates Java code from MontiArc models. Moreover, it distributes MontiArc models as jars with <code>.arcsym</code> files.</p>"},{"location":"usage/MontiArcGradlePlugin/#apply-it","title":"Apply it:","text":"<p>Within gradle's settings script, you need to declare:</p> <p>With Kotlin: <pre><code>// The plugin is in the Maven repo of the chair of Software Engineering at RWTH Aachen.\n// Therefore we have to make it available to our build process.\npluginManagement {\n  repositories {\n    maven {\n      url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n    }\n  }\n}\n</code></pre></p> <p>With Groovy: <pre><code>// The plugin is in the Maven repo of the chair of Software Engineering at RWTH Aachen.\n// Therefore we have to make it available to our build process.\npluginManagement {\n  repositories {\n    maven {\n      url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n    }\n  }\n}\n</code></pre></p> <p>Then, within the build script, you need to declare:</p> <p>With Kotlin: <pre><code>plugins {\n  id(\"montiarc\") version \"VERSION_YOU_WANT_TO_USE\"\n}\n\n// The generator and RTE classes are in the Maven repo of the chair of Software Engineering at RWTH Aachen\nrepositories {\n  maven {\n    url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n  }\n}\n</code></pre></p> <p>With Groovy: <pre><code>plugins {\n  id \"montiarc\" version \"VERSION_YOU_WANT_TO_USE\"\n}\n\n// The generator and RTE classes are in the Maven repo of the chair of Software Engineering at RWTH Aachen\nrepositories {\n  maven {\n    url = uri(\"https://nexus.se.rwth-aachen.de/content/groups/public/\")\n  }\n}\n</code></pre></p>"},{"location":"usage/MontiArcGradlePlugin/#configure-it","title":"Configure it:","text":"<p>The plugin adds a MontiArcCompile task for every source set that exists. The name of that task is <code>compileSRC_SET_NAMEMontiarc</code>, omitting the name of the source set for the main source set.</p> <p>Note that Java source files that the MontiArc generator produces are automatically added to the Java source of the same source set. Therefor, the generated source code will automatically be compiled by <code>compileJava</code> (or <code>compileTestJava</code>, etc. )</p> <p>With Kotlin: <pre><code>// Kotlin:\nsourceSets {\n  main {\n    montiarc {\n      srcDir(\"where/your/montiarc/models/are\")  // default value: $projectDir/src/SOURCE_SET_NAME/montiarc\n      destinationDirectory.fileValue(file(\"where/to/generate/the/code/to\"))  // default value: $buildDir/montiarc/SOURCE_SET_NAME\n    }\n  }\n}\n\n// Declare dependencies on published models\ndependencies {\n  montiarc(\"some.model.publisher:logic-gates:1.2.0\")\n  cd2pojo4montiarc(\"some.class:diagram.types:1.1.0\")\n  testMontiarc(\"some.testModel.publisher:logic-gates:1.2.0\")\n}\n\ntask.compileMontiarc {  // compile task for other sourceSets: \"compile{SRC_SET_NAME}Montiarc\"\n  symbolImportDir.from(\"${projectDir}/src/SRC_SET_NAME/more_symbols\")\n  useClass2Mc.set(true)  // Default value is false\n}\n\nmontiarc {\n  // Only use the following option if you build the MontiArc project itself!\n  // Else ignore it (You can just omit the option).\n  internalMontiArcTesting.set(true)\n}\n</code></pre></p> <p>With Groovy: <pre><code>sourceSets {\n  main {\n    montiarc {\n      srcDir \"where/your/montiarc/models/are\"  // default value: $projectDir/src/SOURCE_SET_NAME/montiarc\n      destinationDirectory.fileValue(file(\"where/to/generate/the/code/to\"))  // default value: $buildDir/montiarc/SOURCE_SET_NAME\n    }\n  }\n}\n\n// Declare dependencies on published models\ndependencies {\n    montiarc \"some.model.publisher:logic-gates:1.2.0\"\n    cd2pojo4montiarc \"some.class:diagram.types:1.1.0\"\n    testMontiarc \"some.testModel.publisher:logic-gates:1.2.0\"\n}\n\ntask.compileMontiarc {  // compile task for other sourceSets: \"compile{SRC_SET_NAME}Montiarc\"\n  symbolImportDir.from(\"${projectDir}/src/SRC_SET_NAME/more_symbols\")\n  useClass2Mc.set(true)  // Default value is false\n}\n\nmontiarc {\n  // Only use the following option if you build the MontiArc project itself!\n  // Else ignore it (You can just omit the option).\n  internalMontiArcTesting.set(true)\n}\n</code></pre></p> <p>Note that the generated java code will be generated to <code>$destinationDirectory/java</code> and created <code>.arcsym</code> files are placed in <code>$destinationDirectory/symbols</code> (<code>destinationDirectory</code> being defined in the <code>montiarc</code> entry of the source set).</p>"},{"location":"usage/MontiArcGradlePlugin/#configuration-options-in-detail","title":"Configuration options in detail:","text":"<p>Each MontiArcCompile task has the following configuration options that can be set. Some configuration options only have default values, if the task is created for a source set. </p> Option Default value Description modelPath <code>$projectDir/src/SOURCE_SET_NAME/montiarc</code> Where to find the MontiArc models for which Java code should be generated. You can specify multiple locations with multiple <code>modelPath.from(...)</code> statements. hwcPath All java code from the same source set (main, or test, etc.) Where to find the handwritten code extensions for the generated MontiArc code. symbolImportDir The <code>montiarcSymbolDependencies</code> configuration If you want to use <code>.sym</code> files, then you can use this configuration parameter to inform the generator where to find them. You can specify multiple locations with multiple <code>symbolImportDir.from(...)</code> statements. useClass2Mc <code>false</code> If you want to use java types (or other JVM types) in your MontiArc models, then you set this configuration parameter to <code>true</code>. By this, all JVM types that are on the class path of the generator (which is the configuration <code>maGenerator</code>) will be accessible from MontiArc models. Note: this will be changed in the future. outputDir <code>$buildDir/montiarc/SOURCE_SET_NAME</code> Where the generated files should be placed. Generated Java code ist placed in the <code>java</code> subfolder, exported symbol files are put in the <code>symbols</code> subfolder. <p>Moreover, there are the following options configurable in the <code>montiarc</code> block:</p> Option Default value Description internalMontiArcTesting <code>false</code> If you are not a MontiArc developer, just ignore it (and omit the option, as its default value is <code>false</code>). Otherwise: if you want to apply the plugin from within the MontiArc project, e.g., to test the generator in an integration test, then set this to <code>true</code>. By this, the freshly compiled (unpublished) generator will be used instead of the one from the maven repository."},{"location":"usage/MontiArcGradlePlugin/#interplay-with-cd2pojo","title":"Interplay with cd2pojo","text":"<p>If the [<code>cd2pojo</code> plugin][Cd2Pojo Plugin] is also applied, then the class diagram models defined therein are also available in the MontiArc models of the same source set.</p>"},{"location":"usage/MontiArcGradlePlugin/#added-build-elements","title":"Added build elements","text":"<ul> <li>The Plugin adds the dependency configuration maGenerator on which it places the dependency on the generator that is   used to generate .java code from the .arc files. If you use <code>class2mc</code>, then you can place the java classes that you   want to use in your models on this configuration.</li> <li>For every SourceSet, the plugin</li> <li>Adds a [MontiarcCompile] task that performs the generation step from .arc models     to .java code. The task name is <code>compileMontiarc</code> for main and <code>compileSourceSetNameMontiarc</code> for others</li> <li>Adds a jar task packaging the .arcsym models of the main source set, adding it to the default publication.</li> <li>Adds three configurations:<ul> <li><code>montiarc</code> for the main source set and <code>sourceSetNameMontiarc</code> for others:\\   Used to declare dependencies on other MontiArc models. This configuration is not resolvable or consumable and only   serves the purpose to declare dependencies. The models of the dependencies will automatically be added to   the <code>compileMontiarc</code> task and their java implementations will automatically be added to the   <code>implementation</code> configuration for compilation and runtime.</li> <li><code>cd4pojo4montiarc</code> for the main source set and <code>sourceSetNameCd2pojo4montiarc</code> for others:\\   Used to declare dependencies of MontiArc models on other class diagram projects. This configuration is not   resolvable or consumable and only serves the purpose to declare dependencies. The models of the dependencies will   automatically be added to the <code>compileMontiarc</code> task and their java implementations will automatically be added to   the <code>implementation</code> configuration for compilation and runtime.</li> <li><code>montiarcSymbolDependencies</code> for the main source set and <code>sourceSetNameMontiarcSymbolDependencies</code> for others:\\   Loads the MontiArc dependencies (represented by .arcsym files). Do not use    this configuration to declare the dependencies (use <code>montiarc</code> for this purpose instead), but use this   configuration, when you want to access the MontiArc models of the dependencies. (This configuration is   automatically derived from the <code>montiarc</code> configuration, only considering the montiarc models.)</li> <li><code>cd2pojo4montiarcSymbolDependencies</code> for the main source set and <code>sourceSetNameCd2pojo4montiarcSymbolDependencies</code>   for others:\\   Loads the class diagram dependencies of our MontiArc models (represented by .cdsym files). Do not use   this configuration to declare the dependencies (use <code>cd2pojo4montiarc</code> for this purpose instead), but use this   configuration, when you want to access the class diagram dependencies. (This configuration is   automatically derived from the <code>cd2pojo4montiarc</code> configuration, only considering the class diagram models.)</li> <li><code>montiarcSymbolElements</code> for the main source set and <code>sourceSetNameMontiarcSymbolElements</code> for others:\\   Contains the jar of the MontiArc models (represented by .arcsym files) that is added to the default publication   set. Is also used to publish the list of MontiArc dependencies of this project. To this end, it extends the   <code>montiarc</code> configuration. By default, this configuration is only added for the main source set.</li> <li><code>cd2pojo4montiarcSymbolDependencyElements</code> for the main source set and   <code>sourceSetNameCd2pojo4montiarcSymbolDependencyElements</code> for others:\\   Used to publish the list of class diagram dependencies of our MontiArc models. To this end, it extends the   <code>cd2pojo4montiarc</code> configuration. By default, this configuration is only added for the main source set.   If the project also applies the <code>cd2pojo</code> plugin, then the cd-symbols jar is also published with this   configuration. This is due to technical reasons.</li> </ul> </li> <li>Models declared in the main source set are also available in the test source sets.</li> </ul>"},{"location":"usage/MontiArcGradlePlugin/#fixing-problems","title":"Fixing problems:","text":"<ul> <li>The generator only generates classes with a TOP postfix\\     When you use the default value of the hwcPath, the outputDir may erroneously be in the hwcPath, because      filtering the outputDir went wrong. In this case the generator thinks that the previously generated files are     handwritten extensions. To fix this, you should set the hwcPath manually. This will overwrite the default value,     including the entry with the outputDir.</li> <li>There is no main or test source set\\     These source sets only exist if the java plugin is applied. If only the java-base plugin is applied, then there   are no main or tests source sets.</li> <li>If your dependencies use class2mc, then you have to activate it for your own project, too.</li> <li>If you activate class2mc for your main source set, you also have to activate it for your test source set.</li> </ul>"}]}