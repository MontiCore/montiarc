/* (c) https://github.com/MontiCore/monticore */
import montiarc.tooling.plugin.getCompileMontiarcTaskName
import montiarc.tooling.plugin.MontiarcCompile

/**
 * This build is mostly a test specification. It defines configurations for different compileMontiarc tasks
 * and also defines a task that checks that the correct .java files are generated by them.
 */

buildscript {
  dependencies {
    classpath("montiarc.tooling:plugin")
  }
}

plugins {
  id("montiarc.build.repositories")
  id("montiarc.build.modules")
  id("montiarc.build.project-version")

  id("java")
  id("montiarc")
}

group = "montiarc.tooling.plugin-itest"

montiarc {
  internalMontiArcTesting.set(true)
}



// Testing correct behavior in the case of fully altered configuration values
val alteredConfigValuesSrcSet = sourceSets.create("alteringAndUsingConfigValues") {
  montiarc.setSrcDirs(listOf("$projectDir/src/${this.name}/alteredMontiarc"))
  montiarc.destinationDirectory.set(layout.buildDirectory.dir("montiarc-for-altered-destination"))
}

val alteredConfigValuesImplConfig = configurations.getByName(alteredConfigValuesSrcSet.implementationConfigurationName)
tasks.named<MontiarcCompile>(alteredConfigValuesSrcSet.getCompileMontiarcTaskName()) {
  val srcSet = alteredConfigValuesSrcSet
  hwcPath.setFrom("$projectDir/src/${srcSet.name}/alteredJavaHwc")
  symbolImportDir.setFrom("$projectDir/src/${srcSet.name}/alteredSymbolsDir")
  useClass2Mc.set(true)
  libModels.setFrom("$projectDir/src/${srcSet.name}/alteredLibModels")
}

val alteredConfigCheck = tasks.register("checkAlteringConfigValues", CheckFilesArePresent::class.java) {
  dependsOn(tasks.named(alteredConfigValuesSrcSet.getCompileMontiarcTaskName()))
  group = "verification"

  val expectedGenDir = "$buildDir/montiarc-for-altered-destination"
  val expectedJavaGenDir = "$expectedGenDir/java"
  val expectedSymbolGenDir = "$expectedGenDir/symbols"

  mandatoryFiles.from(
    "$expectedJavaGenDir/mainpackage/HwcComponentTOP.java",
    "$expectedJavaGenDir/mainpackage/UsingLibModelsAndImportedSymbols.java",
    "$expectedSymbolGenDir/mainpackage/HwcComponent.arcsym",
    "$expectedSymbolGenDir/mainpackage/UsingLibModelsAndImportedSymbols.arcsym",
  )
}
tasks.check.configure { dependsOn(alteredConfigCheck) }



// Testing correct behavior if we provide multiple paths where possible
val multiplePathsSrcSet = sourceSets.create("usingMultiplePathsAsConfigValues") {
  montiarc.setSrcDirs(listOf(
    "$projectDir/src/${this.name}/montiarc",
    "$projectDir/src/${this.name}/montiarc2",
  ))
}

val multiplePathsImplConfig = configurations.getByName(multiplePathsSrcSet.implementationConfigurationName)
tasks.named<MontiarcCompile>(multiplePathsSrcSet.getCompileMontiarcTaskName()) {
  val srcSet = multiplePathsSrcSet
  hwcPath.setFrom(
    "$projectDir/src/${srcSet.name}/java",
    "$projectDir/src/${srcSet.name}/java2",
  )
  symbolImportDir.setFrom(
    "$projectDir/src/${srcSet.name}/symbols",
    "$projectDir/src/${srcSet.name}/symbols2",
  )
  libModels.from(
    "$projectDir/src/${srcSet.name}/libModels",
    "$projectDir/src/${srcSet.name}/libModels2",
  )
}

val multiplePathsCheck = tasks.register("checkMultiplePaths", CheckFilesArePresent::class.java) {
  dependsOn(tasks.named(multiplePathsSrcSet.getCompileMontiarcTaskName()))
  group = "verification"

  val expectedGenDir = "$buildDir/montiarc/${multiplePathsSrcSet.name}"
  val expectedJavaGenDir = "$expectedGenDir/java"
  val expectedSymbolGenDir = "$expectedGenDir/symbols"

  mandatoryFiles.from(
    "$expectedJavaGenDir/mainpackage/HwcComponentTOP.java",
    "$expectedJavaGenDir/mainpackage/HwcComponent2TOP.java",
    "$expectedJavaGenDir/mainpackage/UsingComponentFromOtherModelPath.java",
    "$expectedJavaGenDir/mainpackage/UsingLibModelsAndImportedSymbols.java",
    "$expectedJavaGenDir/mainpackage/ComponentFromModelPath2.java",
    "$expectedSymbolGenDir/mainpackage/HwcComponent.arcsym",
    "$expectedSymbolGenDir/mainpackage/HwcComponent2.arcsym",
    "$expectedSymbolGenDir/mainpackage/UsingComponentFromOtherModelPath.arcsym",
    "$expectedSymbolGenDir/mainpackage/UsingLibModelsAndImportedSymbols.arcsym",
    "$expectedSymbolGenDir/mainpackage/ComponentFromModelPath2.arcsym"
  )
}
tasks.check.configure { dependsOn(multiplePathsCheck) }



// Testing correct behavior if we provide multiple paths where possible, some existing, some not,
val mixedPathsExistanceSrcSet = sourceSets.create("usingMultiplePathsMixedExistanceAsConfigValues") {
  montiarc.setSrcDirs(listOf(
    "$projectDir/src/${this.name}/montiarc",
    "$projectDir/src/${this.name}/montiarcNotExisting",
  ))
}

val mixedPathsImplConfig = configurations.getByName(mixedPathsExistanceSrcSet.implementationConfigurationName)
tasks.named<MontiarcCompile>(mixedPathsExistanceSrcSet.getCompileMontiarcTaskName()) {
  val srcSet = mixedPathsExistanceSrcSet
  hwcPath.setFrom(
    "$projectDir/src/${srcSet.name}/java",
    "$projectDir/src/${srcSet.name}/javaNotExisting",
  )
  symbolImportDir.setFrom(
    "$projectDir/src/${srcSet.name}/symbols",
    "$projectDir/src/${srcSet.name}/symbolsNotExisting",
  )
  libModels.setFrom(
    "$projectDir/src/${srcSet.name}/libModels",
    "$projectDir/src/${srcSet.name}/libModelsNotExisting",
  )
}

val mixedPathExistenceCheck = tasks.register("checkMultipleMixedPathExistence", CheckFilesArePresent::class.java) {
  dependsOn(tasks.named(mixedPathsExistanceSrcSet.getCompileMontiarcTaskName()))
  group = "verification"

  val expectedGenDir = "$buildDir/montiarc/${mixedPathsExistanceSrcSet.name}"
  val expectedJavaGenDir = "$expectedGenDir/java"
  val expectedSymbolGenDir = "$expectedGenDir/symbols"

  mandatoryFiles.from(
    "$expectedJavaGenDir/mainpackage/HwcComponentTOP.java",
    "$expectedJavaGenDir/mainpackage/UsingLibModelsAndImportedSymbols.java",
    "$expectedSymbolGenDir/mainpackage/HwcComponent.arcsym",
    "$expectedSymbolGenDir/mainpackage/UsingLibModelsAndImportedSymbols.arcsym"
  )
}
tasks.check.configure { dependsOn(mixedPathExistenceCheck) }



// Testing correct behavior if we fully remove configuration values where possible
// For this source set, we do not remove the model path directory, as it would lead to "NO_SOURCE", disabling testing
val removingSrcSet = sourceSets.create("removingDefaultValues")
val removingImplConfig = configurations.getByName(removingSrcSet.implementationConfigurationName)
tasks.named<MontiarcCompile>(removingSrcSet.getCompileMontiarcTaskName()) {
  hwcPath.setFrom()
  symbolImportDir.setFrom()
  libModels.setFrom()
}

val removingDefaultValuesCheck = tasks.register("checkRemovingDefaultValues", CheckFilesArePresent::class.java) {
  dependsOn(tasks.named(removingSrcSet.getCompileMontiarcTaskName()))
  group = "verification"

  val expectedGenDir = "$buildDir/montiarc/${removingSrcSet.name}"
  val expectedJavaGenDir = "$expectedGenDir/java"
  val expectedSymbolGenDir = "$expectedGenDir/symbols"

  mandatoryFiles.from(
    "$expectedJavaGenDir/mainpackage/NoHwcComponent.java",
    "$expectedSymbolGenDir/mainpackage/NoHwcComponent.arcsym"
  )
}
tasks.check.configure { dependsOn(removingDefaultValuesCheck) }



// Testing correct behavior if we change configuration values to unused or absent paths where possible
// For this source set, declaring only an unused model path directory would lead to "NO_SOURCE", disabling testing
val unusedConfigValuesSrcSet = sourceSets.create("declaringUnusedConfigValues")
val unusedConfigValuesImplConfig = configurations.getByName(unusedConfigValuesSrcSet.implementationConfigurationName)
tasks.named<MontiarcCompile>(unusedConfigValuesSrcSet.getCompileMontiarcTaskName()) {
  val srcSet = unusedConfigValuesSrcSet
  hwcPath.setFrom(file("$projectDir/src/${srcSet.name}/unusedJava"))
  symbolImportDir.setFrom(file("$projectDir/src/${srcSet.name}/unusedSymbols"))
  libModels.setFrom(file("$projectDir/src/${srcSet.name}/unusedLibModels"))
}

val unusedConfigValuesCheck = tasks.register("checkUnusedConfigValues", CheckFilesArePresent::class.java) {
  dependsOn(tasks.named(unusedConfigValuesSrcSet.getCompileMontiarcTaskName()))
  group = "verification"

  val expectedGenDir = "$buildDir/montiarc/${unusedConfigValuesSrcSet.name}"
  val expectedJavaGenDir = "$expectedGenDir/java"
  val expectedSymbolGenDir = "$expectedGenDir/symbols"

  mandatoryFiles.from(
    "$expectedJavaGenDir/mainpackage/NoHwcComponent.java",
    "$expectedSymbolGenDir/mainpackage/NoHwcComponent.arcsym"
  )
}
tasks.check.configure { dependsOn(unusedConfigValuesCheck) }



dependencies {
  alteredConfigValuesImplConfig(project(":libraries:majava-rte"))
  multiplePathsImplConfig(project(":libraries:majava-rte"))
  mixedPathsImplConfig(project(":libraries:majava-rte"))
  removingImplConfig(project(":libraries:majava-rte"))
  unusedConfigValuesImplConfig(project(":libraries:majava-rte"))
}


tasks.getByName<Test>("test") {
  this.enabled = false
}

abstract class CheckFilesArePresent : DefaultTask() {

  @get:InputFiles
  abstract val mandatoryFiles: ConfigurableFileCollection

  @TaskAction
  fun execute() {
    val absentFiles = mandatoryFiles.files.filter { !it.exists() }
    if (absentFiles.isNotEmpty()) {
      val errorMsg = absentFiles.joinToString(separator = "\n") { "Missing expected file: ${it.path}" }

      throw VerificationException(errorMsg)
    }
  }
}

